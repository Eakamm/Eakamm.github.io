<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Eakamm.github.io</id>
    <title>刘志豪的博客</title>
    <updated>2021-01-07T07:25:37.473Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Eakamm.github.io"/>
    <link rel="self" href="https://Eakamm.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Eakamm.github.io/images/avatar.png</logo>
    <icon>https://Eakamm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 刘志豪的博客</rights>
    <entry>
        <title type="html"><![CDATA[Sql 尽量避免使用IN或NOT IN]]></title>
        <id>https://Eakamm.github.io/post/sql-jin-liang-bi-mian-shi-yong-in-huo-not-in/</id>
        <link href="https://Eakamm.github.io/post/sql-jin-liang-bi-mian-shi-yong-in-huo-not-in/">
        </link>
        <updated>2021-01-07T07:20:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.cnblogs.com/totian/p/7597300.html">www.cnblogs.com</a><br>
WHY？<br>
====</p>
</blockquote>
<p>IN 和 NOT IN 是比较常用的关键字，为什么要尽量避免呢？</p>
<p><strong>1、效率低</strong></p>
<p>可以参看我之前遇到的一个例子（<a href="http://www.cnblogs.com/hydor/p/4288739.html">[小问题笔记（九）] SQL 语句 Not IN 效率低，用 NOT EXISTS 试试</a>）</p>
<p><strong>2、容易出现问题，或查询结果有误</strong> （不能更严重的缺点）</p>
<p>以 IN 为例。建两个表：test1 和 test2</p>
<pre><code class="language-mysql">create table test1 (id1 int)
create table test2 (id2 int)

insert into test1 (id1) values (1),(2),(3)
insert into test2 (id2) values (1),(2)
</code></pre>
<p><strong>我想要查询，在 test2 中存在的  test1 中的 id</strong> 。使用 IN 的一般写法是：</p>
<pre><code class="language-mysql">select id1 from test1 
where id1 in (select id2 from test2)
</code></pre>
<p>结果是：<img src="https://images2015.cnblogs.com/blog/599583/201604/599583-20160414142918832-546624557.jpg" alt="" loading="lazy">  OK 木有问题！</p>
<p>但是如果我一时手滑，写成了：</p>
<pre><code class="language-mysql">select id1 from test1 
where id1 in (select id1 from test2)
</code></pre>
<p>不小心把 id2 写成 id1 了 ，会怎么样呢?</p>
<p>结果是：<img src="https://images2015.cnblogs.com/blog/599583/201604/599583-20160414143058535-1581017335.jpg" alt="" loading="lazy"> <br>
EXCUSE ME！ 为什么不报错？</p>
<p>单独查询 select id1 from test2 是一定会报错: 消息 207，级别 16，状态 1，第 11 行 列名'id1' 无效。</p>
<p>然而使用了 IN 的子查询就是这么敷衍，直接查出 1 2 3</p>
<p>这仅仅是容易出错的情况，自己不写错还没啥事儿，下面来看一下 NOT IN 直接查出错误结果的情况：</p>
<p>给 test2 插入一个空值：</p>
<pre><code class="language-mysql">insert into test2 (id2) values (NULL)
</code></pre>
<p><strong>我想要查询，在 test2 中不存在的  test1 中的 id 。</strong></p>
<pre><code class="language-mysql">select id1 from test1 
where id1 not in (select id2 from test2)
</code></pre>
<p>结果是：<img src="https://images2015.cnblogs.com/blog/599583/201604/599583-20160414144719566-1529158930.jpg" alt="" loading="lazy"> 空白！ 显然这个结果不是我们想要的。我们想要 3。为什么会这样呢？</p>
<p>原因是：NULL 不等于任何非空的值啊！如果 id2 只有 1 和 2， 那么 3&lt;&gt;1 且 3&lt;&gt;2 所以 3 输出了，但是 id2 包含空值，那么 3 也不等于 NULL 所以它不会输出。</p>
<p>（跑题一句：建表的时候最好不要允许含空值，否则问题多多。）</p>
<h1 id="how">HOW？</h1>
<p><strong>1、用 EXISTS 或 NOT EXISTS 代替</strong></p>
<pre><code class="language-mysql">select *  from test1 
   where EXISTS (select * from test2  where id2 = id1 )

select *  FROM test1  
 where NOT EXISTS (select * from test2  where id2 = id1 )
</code></pre>
<p><strong>2、用 JOIN 代替</strong></p>
<pre><code class="language-mysql">select id1 from test1 
   INNER JOIN test2 ON id2 = id1 
   
 select id1 from test1 
   LEFT JOIN test2 ON id2 = id1 
   where id2 IS NULL
</code></pre>
<p>妥妥的没有问题了！</p>
<p>PS：那我们死活都不能用 IN 和 NOT IN 了么？并没有，一位大神曾经说过，如果是<strong>确定且有限的集合</strong>时，可以使用。如 IN （0，1，2）。</p>
<p>转发自：http://www.cnblogs.com/hydor/p/5391556.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL编写技巧]]></title>
        <id>https://Eakamm.github.io/post/sql-bian-xie-ji-qiao/</id>
        <link href="https://Eakamm.github.io/post/sql-bian-xie-ji-qiao/">
        </link>
        <updated>2020-11-04T06:55:58.000Z</updated>
        <content type="html"><![CDATA[<p>1、使用union代替or<br>
力扣习题：<a href="https://leetcode-cn.com/problems/big-countries/">595. 大的国家</a><br>
union将查询的结果合并到一起，会去重，重复数据只会出现一次。<br>
union all 将结果全部列出</p>
<p>原始数据</p>
<pre><code class="language-sql">-- websites
+----+--------------+---------------------------+-------+---------+
| id | name         | url                       | alexa | country |
+----+--------------+---------------------------+-------+---------+
| 1  | Google       | https://www.google.cm/    | 1     | USA     |
| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |
| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |
| 4  | 微博          | http://weibo.com/         | 20    | CN      |
| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |
| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |
+----+---------------+---------------------------+-------+---------+
-- apps
+----+------------+-------------------------+---------+
| id | app_name   | url                                   | country |
+----+------------+-------------------------+---------+
|  1 | QQ APP     | http://im.qq.com/            | CN         |
|  2 | 微博 APP    | http://weibo.com/           | CN         |
|  3 | 淘宝 APP    | https://www.taobao.com/  | CN         |
+----+------------+-------------------------+---------+
</code></pre>
<p><strong>union</strong></p>
<pre><code class="language-sql">SELECT country FROM Websites
UNION
SELECT country FROM apps
</code></pre>
<p><strong>union all</strong></p>
<pre><code class="language-sql">SELECT country FROM Websites
UNION ALL
SELECT country FROM apps
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lombok的坑大小写问题]]></title>
        <id>https://Eakamm.github.io/post/lombok-de-keng-da-xiao-xie-wen-ti/</id>
        <link href="https://Eakamm.github.io/post/lombok-de-keng-da-xiao-xie-wen-ti/">
        </link>
        <updated>2020-10-22T01:56:50.000Z</updated>
        <summary type="html"><![CDATA[<p>在我使用post请求提交数据的时候，使用@Data注释的实体类set方法不能正常使用，通过查找资料发现是大小写问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在我使用post请求提交数据的时候，使用@Data注释的实体类set方法不能正常使用，通过查找资料发现是大小写问题。</p>
<!-- more -->
<p>我Post提交的请求数据是</p>
<pre><code class="language-json">{
      &quot;vId&quot;: 1,
     &quot;dIds&quot;: [6,7]
}
</code></pre>
<p>后端的实体类为VoteDetailRelVo，使用了@Data注解。</p>
<pre><code class="language-java">@Data
public class VoteDetailRelVo {

    private Long vId;

    private List&lt;Long&gt; dIds;
}
</code></pre>
<p>lombok自动生成的get/set方法变为了<code>getVId/setVId</code>与<code>getDIds/setDIds</code>。</p>
<p>一般JavaBean属性以小写字母开头，驼峰命名格式，相应的 getter/setter 方法是 get/set 接上首字母大写的属性名。例如：属性名为userName，其对应的getter/setter 方法是 getUserName/setUserName。</p>
<p>但是，还有一些特殊情况：</p>
<p>1、如果属性名的第二个字母大写，那么该属性名直接用作 getter/setter 方法中 get/set 的后部分，就是说大小写不变。例如属性名为uName，方法是getuName/setuName。</p>
<p>2、如果前两个字母是大写（一般的专有名词和缩略词都会大写），也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为URL，方法是getURL/setURL。</p>
<p>3、如果首字母大写，也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为Name，方法是getName/setName，这种是最糟糕的情况，会找不到属性出错，因为默认的属性名是name。</p>
<p>所以Lombok生成的的get/set方法会出现问题。<br>
详解可见https://www.cnblogs.com/sunTin/p/7172932.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 常用时间比较方式]]></title>
        <id>https://Eakamm.github.io/post/java-chang-yong-shi-jian-bi-jiao-fang-shi/</id>
        <link href="https://Eakamm.github.io/post/java-chang-yong-shi-jian-bi-jiao-fang-shi/">
        </link>
        <updated>2020-10-19T08:23:13.000Z</updated>
        <summary type="html"><![CDATA[<p>本文将描述在java中进行日期时间比较的4种方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文将描述在java中进行日期时间比较的4种方法</p>
<!-- more -->
<p><a href="https://c.lanmit.com/bianchengkaifa/Java/59964.html">本文地址：</a><br>
&gt; 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [c.lanmit.com](https://c.lanmit.com/bianchengkaifa/Java/59964.html)</p>
<p>本文将为您描述在 java 中进行日期时间比较的 4 种方法, 教程操作步骤:</p>
<p>1. Date.compareTo（）</p>
<p><code>java.util.Date</code>提供了在 Java 中比较两个日期的经典方法 compareTo（）。</p>
<p>如果两个日期相等，则返回值为 0。 如果 Date 在 date 参数之后，则返回值大于 0。 如果 Date 在 date 参数之前，则返回值小于 0。</p>
<pre><code>@Test
void testDateCompare() throws ParseException {
  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
  Date date1 = sdf.parse(&quot;2009-12-31&quot;);
  Date date2 = sdf.parse(&quot;2019-01-31&quot;);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  if (date1.compareTo(date2) &gt; 0) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  } else if (date1.compareTo(date2) &lt; 0) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  } else if (date1.compareTo(date2) == 0) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  } else {
    System.out.println(&quot;程序怎么会运行到这里?正常应该不会&quot;);
  }
}
</code></pre>
<p>输出结果：</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Date1 时间在 Date2 之前
</code></pre>
<p>2. Date.before（），Date.after（）和 Date.equals（）</p>
<p>一种语义上比较友好的方法来比较两个<code>java.util.Date</code></p>
<pre><code>@Test
void testDateCompare2() throws ParseException {
  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
  Date date1 = sdf.parse(&quot;2009-12-31&quot;);
  Date date2 = sdf.parse(&quot;2019-01-31&quot;);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  if (date1.after(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  }

  if (date1.before(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  }

  if (date1.equals(date2)) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  }
}
</code></pre>
<p>输出结果</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Date1 时间在 Date2 之前
</code></pre>
<p>3. Calender.before（），Calender.after（）和 Calender.equals（）</p>
<p>使用<code>java.util.Calendar</code>比较两个 Date 日期</p>
<pre><code>@Test
void testDateCompare3() throws ParseException {
  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
  Date date1 = sdf.parse(&quot;2009-12-31&quot;);
  Date date2 = sdf.parse(&quot;2019-01-31&quot;);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  Calendar cal1 = Calendar.getInstance();
  Calendar cal2 = Calendar.getInstance();
  cal1.setTime(date1);
  cal2.setTime(date2);

  if (cal1.after(cal2)) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  }

  if (cal1.before(cal2)) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  }

  if (cal1.equals(cal2)) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  }
}
</code></pre>
<p>输出结果：</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Date1 时间在 Date2 之前
</code></pre>
<p>4. Java 8 日期比较方法</p>
<p>在 Java 8 中，可以使用新的 isBefore（），isAfter（），isEqual（）和 compareTo（）来比较 LocalDate，LocalTime 和 LocalDateTime。以下示例以比较两个<code>java.time.LocalDate</code></p>
<pre><code>@Test
void testDateCompare4() throws ParseException {
  DateTimeFormatter sdf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);
  LocalDate date1 = LocalDate.of(2009, 12, 31);
  LocalDate date2 = LocalDate.of(2019, 1, 31);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  System.out.println(&quot;Is...&quot;);
  if (date1.isAfter(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  }

  if (date1.isBefore(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  }

  if (date1.isEqual(date2)) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  }
}
</code></pre>
<p>输出结果</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Is...
Date1 时间在 Date2 之前
</code></pre>
<p>本文地址：https://c.lanmit.com/bianchengkaifa/Java/59964.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sql窗口函数--排名问题]]></title>
        <id>https://Eakamm.github.io/post/sql-chuang-kou-han-shu-pai-ming-wen-ti/</id>
        <link href="https://Eakamm.github.io/post/sql-chuang-kou-han-shu-pai-ming-wen-ti/">
        </link>
        <updated>2020-10-19T01:02:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-mysql">select *,
   rank() over (order by 成绩 desc) as ranking,
   dense_rank() over (order by 成绩 desc) as dese_rank,
   row_number() over (order by 成绩 desc) as row_num
from 班级
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot与Quartz整合]]></title>
        <id>https://Eakamm.github.io/post/springboot-yu-quartz-zheng-he/</id>
        <link href="https://Eakamm.github.io/post/springboot-yu-quartz-zheng-he/">
        </link>
        <updated>2020-10-09T08:16:59.000Z</updated>
        <summary type="html"><![CDATA[<p>Quartz 是一个很牛的任务调度框架，通过它我们可以实现诸如: 定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。记录一下与SpringBoot整合的过程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Quartz 是一个很牛的任务调度框架，通过它我们可以实现诸如: 定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。记录一下与SpringBoot整合的过程。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Quartz作业调度]]></title>
        <id>https://Eakamm.github.io/post/quartz-zuo-ye-diao-du/</id>
        <link href="https://Eakamm.github.io/post/quartz-zuo-ye-diao-du/">
        </link>
        <updated>2020-10-09T00:49:44.000Z</updated>
        <summary type="html"><![CDATA[<p>Quartz是一个很牛的任务调度框架，通过它我们可以实现诸如:定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Quartz是一个很牛的任务调度框架，通过它我们可以实现诸如:定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。</p>
<!-- more -->
<h2 id="一-什么是-quartz">一、什么是 Quartz</h2>
<p>什么是 Quartz?</p>
<blockquote>
<p>Quartz 是 OpenSymphony 开源组织在 Job scheduling 领域又一个开源项目，完全由 Java 开发，可以用来执行定时任务，类似于 java.util.Timer。但是相较于 Timer， Quartz 增加了很多功能：</p>
<ul>
<li>持久性作业 - 就是保持调度定时的状态;</li>
<li>作业管理 - 对调度作业进行有效的管理;</li>
</ul>
</blockquote>
<p>大部分公司都会用到定时任务这个功能。<br>
拿火车票购票来说，当你下单后，后台就会插入一条待支付的 task(job)，一般是 30 分钟，超过 30min 后就会执行这个 job，去判断你是否支付，未支付就会取消此次订单；当你支付完成之后，后台拿到支付回调后就会再插入一条待消费的 task（job），Job 触发日期为火车票上的出发日期，超过这个时间就会执行这个 job，判断是否使用等。</p>
<p>在我们实际的项目中，当 Job 过多的时候，肯定不能人工去操作，这时候就需要一个任务调度框架，帮我们自动去执行这些程序。那么该如何实现这个功能呢？</p>
<p>（1）首先我们需要定义实现一个定时功能的接口，我们可以称之为 Task（或 Job），如定时发送邮件的 task（Job），重启机器的 task（Job），优惠券到期发送短信提醒的 task（Job），实现接口如下：<br>
<img src="https://img-blog.csdn.net/20180710135410275?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>（2）有了任务之后，还需要一个能够实现触发任务去执行的触发器，触发器 Trigger 最基本的功能是指定 Job 的执行时间，执行间隔，运行次数等。<br>
<img src="https://img-blog.csdn.net/20180710135421739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>（3）有了 Job 和 Trigger 后，怎么样将两者结合起来呢？即怎样指定 Trigger 去执行指定的 Job 呢？这时需要一个 Schedule，来负责这个功能的实现。<br>
<img src="https://img-blog.csdn.net/20180710135431806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>上面三个部分就是 Quartz 的基本组成部分：</p>
<ul>
<li>调度器：Scheduler</li>
<li>任务：JobDetail</li>
<li>触发器：Trigger，包括 SimpleTrigger 和 CronTrigger</li>
</ul>
<h2 id="二-quartz-demo-搭建">二、Quartz Demo 搭建</h2>
<p>下面来利用 Quartz 搭建一个最基本的 Demo。<br>
1、导入依赖的 jar 包：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
    &lt;artifactId&gt;quartz&lt;/artifactId&gt;
    &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、新建一个能够打印任意内容的 Job：</p>
<pre><code class="language-java">/**
 * Created by wanggenshen
 * Date: on 2018/7/7 16:28.
 * Description: 打印任意内容
 */
public class PrintWordsJob implements Job{

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        String printTime = new SimpleDateFormat(&quot;yy-MM-dd HH-mm-ss&quot;).format(new Date());
        System.out.println(&quot;PrintWordsJob start at:&quot; + printTime + &quot;, prints: Hello Job-&quot; + new Random().nextInt(100));

    }
}
</code></pre>
<p>3、创建 Schedule，执行任务：</p>
<pre><code class="language-java">/**
 * Created by wanggenshen
 * Date: on 2018/7/7 16:31.
 * Description: XXX
 */
public class MyScheduler {

    public static void main(String\[\] args) throws SchedulerException, InterruptedException {
        // 1、创建调度器Scheduler
        SchedulerFactory schedulerFactory = new StdSchedulerFactory();
        Scheduler scheduler = schedulerFactory.getScheduler();
        // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容)
        JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class)
                                        .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();
        // 3、构建Trigger实例,每隔1s执行一次
        Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
                .startNow()//立即生效
                .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                .withIntervalInSeconds(1)//每隔1s执行一次
                .repeatForever()).build();//一直执行

        //4、执行
        scheduler.scheduleJob(jobDetail, trigger);
        System.out.println(&quot;--------scheduler start ! ------------&quot;);
        scheduler.start();

        //睡眠
        TimeUnit.MINUTES.sleep(1);
        scheduler.shutdown();
        System.out.println(&quot;--------scheduler shutdown ! ------------&quot;);


    }
}
</code></pre>
<p>运行程序，可以看到程序每隔 1s 会打印出内容，且在一分钟后结束：<br>
<img src="https://img-blog.csdn.net/20180710135458277?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<h2 id="三-quartz-核心详解">三、Quartz 核心详解</h2>
<p>下面就程序中出现的几个参数，看一下 Quartz 框架中的几个重要参数：</p>
<ul>
<li>Job 和 JobDetail</li>
<li>JobExecutionContext</li>
<li>JobDataMap</li>
<li>Trigger、SimpleTrigger、CronTrigger</li>
</ul>
<p>（1）Job 和 JobDetail<br>
Job 是 Quartz 中的一个接口，接口下只有 execute 方法，在这个方法中编写业务逻辑。<br>
接口中的源码：<br>
<img src="https://img-blog.csdn.net/20180710135513678?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>JobDetail 用来绑定 Job，为 Job 实例提供许多属性：</p>
<ul>
<li>name</li>
<li>group</li>
<li>jobClass</li>
<li>jobDataMap</li>
</ul>
<p>JobDetail 绑定指定的 Job，每次 Scheduler 调度执行一个 Job 的时候，首先会拿到对应的 Job，然后创建该 Job 实例，再去执行 Job 中的 execute() 的内容，任务执行结束后，关联的 Job 对象实例会被释放，且会被 JVM GC 清除。</p>
<p>为什么设计成 JobDetail + Job，不直接使用 Job</p>
<blockquote>
<p>JobDetail 定义的是任务数据，而真正的执行逻辑是在 Job 中。<br>
这是因为任务是有可能并发执行，如果 Scheduler 直接使用 Job，就会存在对同一个 Job 实例并发访问的问题。而 JobDetail &amp; Job 方式，Sheduler 每次执行，都会根据 JobDetail 创建一个新的 Job 实例，这样就可以规避并发访问的问题。</p>
</blockquote>
<p>（2）JobExecutionContext<br>
JobExecutionContext 中包含了 Quartz 运行时的环境以及 Job 本身的详细数据信息。<br>
当 Schedule 调度执行一个 Job 的时候，就会将 JobExecutionContext 传递给该 Job 的 execute() 中，Job 就可以通过 JobExecutionContext 对象获取信息。<br>
主要信息有：<br>
<img src="https://img-blog.csdn.net/20180710135537517?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>（3）JobExecutionContext<br>
JobDataMap 实现了 JDK 的 Map 接口，可以以 Key-Value 的形式存储数据。<br>
JobDetail、Trigger 都可以使用 JobDataMap 来设置一些参数或信息，<br>
Job 执行 execute() 方法的时候，JobExecutionContext 可以获取到 JobExecutionContext 中的信息：<br>
如：</p>
<pre><code class="language-java">JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class)                        .usingJobData(&quot;jobDetail1&quot;, &quot;这个Job用来测试的&quot;)
                  .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();

 Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
      .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)
      .startNow()//立即生效
      .withSchedule(SimpleScheduleBuilder.simpleSchedule()
      .withIntervalInSeconds(1)//每隔1s执行一次
      .repeatForever()).build();//一直执行
</code></pre>
<p>Job 执行的时候，可以获取到这些参数信息：</p>
<pre><code class="language-java">@Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {

        System.out.println(jobExecutionContext.getJobDetail().getJobDataMap().get(&quot;jobDetail1&quot;));
        System.out.println(jobExecutionContext.getTrigger().getJobDataMap().get(&quot;trigger1&quot;));
        String printTime = new SimpleDateFormat(&quot;yy-MM-dd HH-mm-ss&quot;).format(new Date());
        System.out.println(&quot;PrintWordsJob start at:&quot; + printTime + &quot;, prints: Hello Job-&quot; + new Random().nextInt(100));


    }
</code></pre>
<p>（4）Trigger、SimpleTrigger、CronTrigger</p>
<ul>
<li><strong>Trigger</strong></li>
</ul>
<p>Trigger 是 Quartz 的触发器，会去通知 Scheduler 何时去执行对应 Job。</p>
<pre><code>new Trigger().startAt():表示触发器首次被触发的时间;
new Trigger().endAt():表示触发器结束触发的时间;
</code></pre>
<ul>
<li><strong>SimpleTrigger</strong><br>
SimpleTrigger 可以实现在一个指定时间段内执行一次作业任务或一个时间段内多次执行作业任务。<br>
下面的程序就实现了程序运行 5s 后开始执行 Job，执行 Job 5s 后结束执行：</li>
</ul>
<pre><code>Date startDate = new Date();
startDate.setTime(startDate.getTime() + 5000);

 Date endDate = new Date();
 endDate.setTime(startDate.getTime() + 5000);

        Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
                .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)
                .startNow()//立即生效
                .startAt(startDate)
                .endAt(endDate)
                .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                .withIntervalInSeconds(1)//每隔1s执行一次
                .repeatForever()).build();//一直执行
</code></pre>
<ul>
<li><strong>CronTrigger</strong></li>
</ul>
<p>CronTrigger 功能非常强大，是基于日历的作业调度，而 SimpleTrigger 是精准指定间隔，所以相比 SimpleTrigger，CroTrigger 更加常用。CroTrigger 是基于 Cron 表达式的，先了解下 Cron 表达式：<br>
由 7 个子表达式组成字符串的，格式如下：</p>
<blockquote>
<p>[秒] [分] [小时] [日] [月] [周] [年]</p>
</blockquote>
<p>Cron 表达式的语法比较复杂，<br>
如：* 30 10 ? * 1/5 *<br>
表示（从后往前看）<br>
[指定年份] 的 [ 周一到周五][指定月][不指定日][上午 10 时][30 分][指定秒]</p>
<p>又如：00 00 00 ？ * 10,11,12 1#5 2018<br>
表示 2018 年 10、11、12 月的第一周的星期五这一天的 0 时 0 分 0 秒去执行任务。</p>
<p>下面是给的一个例子：<br>
<img src="https://img-blog.csdn.net/20180710135615747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>可通过在线生成 Cron 表达式的工具：<a href="http://cron.qqe2.com/">http://cron.qqe2.com/</a> 来生成自己想要的表达式。<br>
<img src="https://img-blog.csdn.net/20180710135623995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>下面的代码就实现了每周一到周五上午 10:30 执行定时任务</p>
<pre><code class="language-java">/**
 * Created by wanggenshen
 * Date: on 2018/7/7 20:06.
 * Description: XXX
*/
public class MyScheduler2 {
    public static void main(String\[\] args) throws SchedulerException, InterruptedException {
        // 1、创建调度器Scheduler
        SchedulerFactory schedulerFactory = new StdSchedulerFactory();
        Scheduler scheduler = schedulerFactory.getScheduler();
        // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容)
        JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class)
                .usingJobData(&quot;jobDetail1&quot;, &quot;这个Job用来测试的&quot;)
                .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();
        // 3、构建Trigger实例,每隔1s执行一次
        Date startDate = new Date();
        startDate.setTime(startDate.getTime() + 5000);

        Date endDate = new Date();
        endDate.setTime(startDate.getTime() + 5000);

        CronTrigger cronTrigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
                .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)
                .startNow()//立即生效
                .startAt(startDate)
                .endAt(endDate)
                .withSchedule(CronScheduleBuilder.cronSchedule(&quot;\* 30 10 ? \* 1/5 2018&quot;))
                .build();

        //4、执行
        scheduler.scheduleJob(jobDetail, cronTrigger);
        System.out.println(&quot;--------scheduler start ! ------------&quot;);
        scheduler.start();
        System.out.println(&quot;--------scheduler shutdown ! ------------&quot;);

    }
}
</code></pre>
<hr>
<p>2018/07/07 20:10 in SH.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot使用GetMapping时对象作为参数，对象的属性不可以_开头]]></title>
        <id>https://Eakamm.github.io/post/springboot-shi-yong-getmapping-shi-dui-xiang-zuo-wei-can-shu-dui-xiang-de-shu-xing-bu-ke-yi-_-kai-tou/</id>
        <link href="https://Eakamm.github.io/post/springboot-shi-yong-getmapping-shi-dui-xiang-zuo-wei-can-shu-dui-xiang-de-shu-xing-bu-ke-yi-_-kai-tou/">
        </link>
        <updated>2020-09-28T03:35:16.000Z</updated>
        <summary type="html"><![CDATA[<p>SpringBoot使用GetMapping时以对象作为参数，对象的属性不可以_开头，在网上也没有找到解释。</p>
]]></summary>
        <content type="html"><![CDATA[<p>SpringBoot使用GetMapping时以对象作为参数，对象的属性不可以_开头，在网上也没有找到解释。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js中跳出forEach循环]]></title>
        <id>https://Eakamm.github.io/post/js-zhong-tiao-chu-foreach-xun-huan/</id>
        <link href="https://Eakamm.github.io/post/js-zhong-tiao-chu-foreach-xun-huan/">
        </link>
        <updated>2020-09-27T07:08:57.000Z</updated>
        <summary type="html"><![CDATA[<p>在使用forEach中需要在处理后跳出循环，return和break都无法跳出。经过查找资料后，我找到了两种方法可以实现跳出循环。当然可以使用for循环直接解决🌸🐔</p>
]]></summary>
        <content type="html"><![CDATA[<p>在使用forEach中需要在处理后跳出循环，return和break都无法跳出。经过查找资料后，我找到了两种方法可以实现跳出循环。当然可以使用for循环直接解决🌸🐔</p>
<!-- more -->
<h2 id="1-使用trycatch捕获异常实现">1、使用try···catch捕获异常实现</h2>
<pre><code class="language-javascript">try{
var array = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;];
array.forEach(function(item,index){
	if(item == &quot;third&quot;){
		var a = aaaa;// first second 后就报错，就跳出循环了
		throw new Error(&quot;ending&quot;);//报错，就跳出循环
	}else{
		log(item);
	}
})
}catch(e){
	if(e.message == &quot;ending&quot;){
		log(&quot;结束了&quot;) ;
	}else{
		log(e.message);
	}
}
</code></pre>
<h2 id="2-使用arrsome或者arrevery替代">2、使用arr.some()或者arr.every()替代</h2>
<p>some()当内部return true时跳出整个循环。<br>
some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。</p>
<pre><code class="language-javascript">var arr = [1,2,3,4,5];
var num = 3;
arr.some(function(v){
	if(v == num) {
        // 返回true代表测试通过，结束循环
		return true;
	}
console.log(v);
});
</code></pre>
<p>every()当内部return false时跳出整个循环<br>
every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>
<pre><code class="language-javascript">var arr = [1,2,3,4,5];
var num = 3;
arr.every(function(v){
	if(v == num) {
		return false;
	}else{
		console.log(v);
		return true;
	}
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pandas基础（一）]]></title>
        <id>https://Eakamm.github.io/post/pandas-ji-chu-yi/</id>
        <link href="https://Eakamm.github.io/post/pandas-ji-chu-yi/">
        </link>
        <updated>2020-09-25T06:47:37.000Z</updated>
        <summary type="html"><![CDATA[<p>Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。</p>
<!-- more -->
<h2 id="1-servies">1、Servies</h2>
<p>pandas创建一个一维数组</p>
<pre><code class="language-python{cmd}">import pandas as pd
import numpy as np

s = pd.Series(['a', 'b', 'c'], index=[1, 2, 3])

# 获取索引序列
print(s.index)

# 根据索引查找数据
print(s[1])
s[1] = &quot;e&quot;
print(s[1])

print('----------------------------------')
# 多个索引或值查找
s2 = pd.Series([1, 2, 6], index=['a', 'b', 'c'])
# 自定义的索引('a', 'b', 'c')
print(s2[['a', 'b']])
# 第n行(0,1,2)
print(s2[[1, 2]])
# 值小于等于n
print(s2[s2 &lt;= 3])

print('----------------------------------')
# in判断索引是否存在
print(1 in s)

</code></pre>
<p>通过<code>.index</code>改变索引</p>
<pre><code class="language-python"># Series的索引可以通过按位置赋值的方式进行改变
s.index = ['a','b','c']
</code></pre>
<p>Python切片中是不包含尾部的，Series的自定义字符串索引的切片与之不同.</p>
<pre><code class="language-python">import pandas as pd
import numpy as np

# 字符串索引
s = pd.Series([1,2,3], index=['a', 'b', 'c'])
# 数字索引
s1 = pd.Series([1,2,3], index=[1, 2, 3])
s2 = [1,2,3]
print(s2[0:1])
# 根据行数做切片与普通数组的切片相同
print(s1[1:2])
# 自定义字符串索引包含尾部
print(s['a':'b'])

# 可以使用切片更改数据
s['a':'b'] = 4
print(s)
</code></pre>
<h2 id="2-dataframe">2、DataFrame</h2>
<h3 id="21-创建">2.1、创建</h3>
<p>最常用的方式是利用包含等长度列表或NumPy数组的字典来形成DataFrame(某一列没有赋值，会出现缺省值NaN)</p>
<pre><code class="language-python">import pandas as pd

data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
frame = pd.DataFrame(data)

print(frame)
</code></pre>
<p>设置列名与行名，<code>debt</code>列为空，为NaN</p>
<pre><code class="language-python">&gt;&gt;&gt; frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
...                       index=['one', 'two', 'three', 'four',
...                              'five', 'six'])
&gt;&gt;&gt; frame2
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
six    2003  Nevada  3.2  NaN
</code></pre>
<h3 id="22-查找">2.2、查找</h3>
<p><code>loc[]</code>获取某一行的数据</p>
<pre><code class="language-python">import pandas as pd

data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
frame = pd.DataFrame(data)

# 查找某一行
print(frame)
print(frame.loc[1])

# 多个索引查找


# 创建新的一列
frame['test'] = frame.state == 'Ohio'
print(frame)
# 删除一列
del frame['test']
print(frame.columns)
</code></pre>
<h3 id="23-根据布尔值切片">2.3、根据布尔值切片</h3>
<p>可以根据一个布尔值数组选择数据，也可以比较所有的元素，对符合要求的元素执行操作。</p>
<pre><code class="language-python{cmd}">import pandas as pd
import numpy as np
frame = pd.DataFrame(np.arange(20).reshape(4, 5),
                      index=list('abcd'),
                      columns=list('abcde'))
# frame &lt; 5
print(frame &lt; 5)
# 将小于5的元素改为0
frame[frame &lt; 5] = 0
print(frame)
# 根据列的比较结果显示数据
print(frame[frame['b'] &gt; 10])

print(frame)
</code></pre>
<h3 id="24-loc与iloc索引">2.4、loc与iloc索引</h3>
<p>标签选出单行多列的数据可以使用<code>loc</code>（也就是自定义的索引）</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

frame = pd.DataFrame(np.arange(20).reshape(4, 5),
                      index=list('abcd'),
                      columns=list('abcde'))
# 获取某一行
print(frame.loc['a'])
# 获取某一行的n列数据
print(frame.loc['a',['a', 'b']])
# 
print(frame.loc[['a','b'],['a', 'b']])
</code></pre>
<p>整数标签<code>iloc</code>进行类似的数据选择</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

frame = pd.DataFrame(np.arange(20).reshape(4, 5),
                      index=list('abcd'),
                      columns=list('abcde'))
print(frame.iloc[1])

print(frame.iloc[1,[1,2]])

print(frame.iloc[[1,2],[1,2]])
</code></pre>
<h3 id="25-整数索引问题">2.5、整数索引问题</h3>
<pre><code class="language-python">import numpy as np
import pandas as pd


</code></pre>
<p>当使用字符串的索引就不会对s[-1]产生歧义</p>
<p>所以你有一个包含整数的轴索引，数据选择时请始终使用标签索引。</p>
<h3 id="26-广播机制">2.6、广播机制</h3>
<h3 id="27-函数">2.7、函数</h3>
<p>使用<code>apply</code>可以取出每一行或每一列的元素。<code>axis = 'columns'</code>取出每一行，以行为索引。默认为列。<br>
可以使用函数对数据进行更复杂的操作</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

df = pd.DataFrame(np.arange(20).reshape(4, 5),
                  columns=list('abcde'))

# 求每组数据的最大最小值的差


def f(x): return x.max()-x.min()


# 默认为取出每列
series = df.apply(f)
print(series)

# 取出每行
series = df.apply(f, axis=&quot;columns&quot;)
print(series)
</code></pre>
<p>使用<code>applymap</code>取出每个元素</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

df = pd.DataFrame(np.arange(20).reshape(4, 5),
                  columns=list('abcde'))
# 处理所有的元素
# 求平方
def f2(x): return x**2


data_frame = df.applymap(f2)
print(data_frame)

# 处理某一行
data_frame = df.loc[1].map(f2)
print(data_frame)
</code></pre>
]]></content>
    </entry>
</feed>