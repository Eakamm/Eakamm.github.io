<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Eakamm.github.io</id>
    <title>刘志豪的博客</title>
    <updated>2020-10-22T02:25:38.616Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Eakamm.github.io"/>
    <link rel="self" href="https://Eakamm.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Eakamm.github.io/images/avatar.png</logo>
    <icon>https://Eakamm.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 刘志豪的博客</rights>
    <entry>
        <title type="html"><![CDATA[Lombok的坑大小写问题]]></title>
        <id>https://Eakamm.github.io/post/lombok-de-keng-da-xiao-xie-wen-ti/</id>
        <link href="https://Eakamm.github.io/post/lombok-de-keng-da-xiao-xie-wen-ti/">
        </link>
        <updated>2020-10-22T01:56:50.000Z</updated>
        <summary type="html"><![CDATA[<p>在我使用post请求提交数据的时候，使用@Data注释的实体类set方法不能正常使用，通过查找资料发现是大小写问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在我使用post请求提交数据的时候，使用@Data注释的实体类set方法不能正常使用，通过查找资料发现是大小写问题。</p>
<!-- more -->
<p>我Post提交的请求数据是</p>
<pre><code class="language-json">{
      &quot;vId&quot;: 1,
     &quot;dIds&quot;: [6,7]
}
</code></pre>
<p>后端的实体类为VoteDetailRelVo，使用了@Data注解。</p>
<pre><code class="language-java">@Data
public class VoteDetailRelVo {

    private Long vId;

    private List&lt;Long&gt; dIds;
}
</code></pre>
<p>lombok自动生成的get/set方法变为了<code>getVId/setVId</code>与<code>getDIds/setDIds</code>。</p>
<p>一般JavaBean属性以小写字母开头，驼峰命名格式，相应的 getter/setter 方法是 get/set 接上首字母大写的属性名。例如：属性名为userName，其对应的getter/setter 方法是 getUserName/setUserName。</p>
<p>但是，还有一些特殊情况：</p>
<p>1、如果属性名的第二个字母大写，那么该属性名直接用作 getter/setter 方法中 get/set 的后部分，就是说大小写不变。例如属性名为uName，方法是getuName/setuName。</p>
<p>2、如果前两个字母是大写（一般的专有名词和缩略词都会大写），也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为URL，方法是getURL/setURL。</p>
<p>3、如果首字母大写，也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为Name，方法是getName/setName，这种是最糟糕的情况，会找不到属性出错，因为默认的属性名是name。</p>
<p>所以Lombok生成的的get/set方法会出现问题。<br>
详解可见https://www.cnblogs.com/sunTin/p/7172932.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 常用时间比较方式]]></title>
        <id>https://Eakamm.github.io/post/java-chang-yong-shi-jian-bi-jiao-fang-shi/</id>
        <link href="https://Eakamm.github.io/post/java-chang-yong-shi-jian-bi-jiao-fang-shi/">
        </link>
        <updated>2020-10-19T08:23:13.000Z</updated>
        <summary type="html"><![CDATA[<p>本文将描述在java中进行日期时间比较的4种方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文将描述在java中进行日期时间比较的4种方法</p>
<!-- more -->
<p><a href="https://c.lanmit.com/bianchengkaifa/Java/59964.html">本文地址：</a><br>
&gt; 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [c.lanmit.com](https://c.lanmit.com/bianchengkaifa/Java/59964.html)</p>
<p>本文将为您描述在 java 中进行日期时间比较的 4 种方法, 教程操作步骤:</p>
<p>1. Date.compareTo（）</p>
<p><code>java.util.Date</code>提供了在 Java 中比较两个日期的经典方法 compareTo（）。</p>
<p>如果两个日期相等，则返回值为 0。 如果 Date 在 date 参数之后，则返回值大于 0。 如果 Date 在 date 参数之前，则返回值小于 0。</p>
<pre><code>@Test
void testDateCompare() throws ParseException {
  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
  Date date1 = sdf.parse(&quot;2009-12-31&quot;);
  Date date2 = sdf.parse(&quot;2019-01-31&quot;);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  if (date1.compareTo(date2) &gt; 0) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  } else if (date1.compareTo(date2) &lt; 0) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  } else if (date1.compareTo(date2) == 0) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  } else {
    System.out.println(&quot;程序怎么会运行到这里?正常应该不会&quot;);
  }
}
</code></pre>
<p>输出结果：</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Date1 时间在 Date2 之前
</code></pre>
<p>2. Date.before（），Date.after（）和 Date.equals（）</p>
<p>一种语义上比较友好的方法来比较两个<code>java.util.Date</code></p>
<pre><code>@Test
void testDateCompare2() throws ParseException {
  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
  Date date1 = sdf.parse(&quot;2009-12-31&quot;);
  Date date2 = sdf.parse(&quot;2019-01-31&quot;);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  if (date1.after(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  }

  if (date1.before(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  }

  if (date1.equals(date2)) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  }
}
</code></pre>
<p>输出结果</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Date1 时间在 Date2 之前
</code></pre>
<p>3. Calender.before（），Calender.after（）和 Calender.equals（）</p>
<p>使用<code>java.util.Calendar</code>比较两个 Date 日期</p>
<pre><code>@Test
void testDateCompare3() throws ParseException {
  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
  Date date1 = sdf.parse(&quot;2009-12-31&quot;);
  Date date2 = sdf.parse(&quot;2019-01-31&quot;);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  Calendar cal1 = Calendar.getInstance();
  Calendar cal2 = Calendar.getInstance();
  cal1.setTime(date1);
  cal2.setTime(date2);

  if (cal1.after(cal2)) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  }

  if (cal1.before(cal2)) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  }

  if (cal1.equals(cal2)) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  }
}
</code></pre>
<p>输出结果：</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Date1 时间在 Date2 之前
</code></pre>
<p>4. Java 8 日期比较方法</p>
<p>在 Java 8 中，可以使用新的 isBefore（），isAfter（），isEqual（）和 compareTo（）来比较 LocalDate，LocalTime 和 LocalDateTime。以下示例以比较两个<code>java.time.LocalDate</code></p>
<pre><code>@Test
void testDateCompare4() throws ParseException {
  DateTimeFormatter sdf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);
  LocalDate date1 = LocalDate.of(2009, 12, 31);
  LocalDate date2 = LocalDate.of(2019, 1, 31);

  System.out.println(&quot;date1 : &quot; + sdf.format(date1));
  System.out.println(&quot;date2 : &quot; + sdf.format(date2));

  System.out.println(&quot;Is...&quot;);
  if (date1.isAfter(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之后&quot;);
  }

  if (date1.isBefore(date2)) {
    System.out.println(&quot;Date1 时间在 Date2 之前&quot;);
  }

  if (date1.isEqual(date2)) {
    System.out.println(&quot;Date1 时间与 Date2 相等&quot;);
  }
}
</code></pre>
<p>输出结果</p>
<pre><code>date1 : 2009-12-31
date2 : 2019-01-31
Is...
Date1 时间在 Date2 之前
</code></pre>
<p>本文地址：https://c.lanmit.com/bianchengkaifa/Java/59964.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sql窗口函数--排名问题]]></title>
        <id>https://Eakamm.github.io/post/sql-chuang-kou-han-shu-pai-ming-wen-ti/</id>
        <link href="https://Eakamm.github.io/post/sql-chuang-kou-han-shu-pai-ming-wen-ti/">
        </link>
        <updated>2020-10-19T01:02:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-mysql">select *,
   rank() over (order by 成绩 desc) as ranking,
   dense_rank() over (order by 成绩 desc) as dese_rank,
   row_number() over (order by 成绩 desc) as row_num
from 班级
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot与Quartz整合]]></title>
        <id>https://Eakamm.github.io/post/springboot-yu-quartz-zheng-he/</id>
        <link href="https://Eakamm.github.io/post/springboot-yu-quartz-zheng-he/">
        </link>
        <updated>2020-10-09T08:16:59.000Z</updated>
        <summary type="html"><![CDATA[<p>Quartz 是一个很牛的任务调度框架，通过它我们可以实现诸如: 定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。记录一下与SpringBoot整合的过程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Quartz 是一个很牛的任务调度框架，通过它我们可以实现诸如: 定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。记录一下与SpringBoot整合的过程。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Quartz作业调度]]></title>
        <id>https://Eakamm.github.io/post/quartz-zuo-ye-diao-du/</id>
        <link href="https://Eakamm.github.io/post/quartz-zuo-ye-diao-du/">
        </link>
        <updated>2020-10-09T00:49:44.000Z</updated>
        <summary type="html"><![CDATA[<p>Quartz是一个很牛的任务调度框架，通过它我们可以实现诸如:定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Quartz是一个很牛的任务调度框架，通过它我们可以实现诸如:定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。</p>
<!-- more -->
<h2 id="一-什么是-quartz">一、什么是 Quartz</h2>
<p>什么是 Quartz?</p>
<blockquote>
<p>Quartz 是 OpenSymphony 开源组织在 Job scheduling 领域又一个开源项目，完全由 Java 开发，可以用来执行定时任务，类似于 java.util.Timer。但是相较于 Timer， Quartz 增加了很多功能：</p>
<ul>
<li>持久性作业 - 就是保持调度定时的状态;</li>
<li>作业管理 - 对调度作业进行有效的管理;</li>
</ul>
</blockquote>
<p>大部分公司都会用到定时任务这个功能。<br>
拿火车票购票来说，当你下单后，后台就会插入一条待支付的 task(job)，一般是 30 分钟，超过 30min 后就会执行这个 job，去判断你是否支付，未支付就会取消此次订单；当你支付完成之后，后台拿到支付回调后就会再插入一条待消费的 task（job），Job 触发日期为火车票上的出发日期，超过这个时间就会执行这个 job，判断是否使用等。</p>
<p>在我们实际的项目中，当 Job 过多的时候，肯定不能人工去操作，这时候就需要一个任务调度框架，帮我们自动去执行这些程序。那么该如何实现这个功能呢？</p>
<p>（1）首先我们需要定义实现一个定时功能的接口，我们可以称之为 Task（或 Job），如定时发送邮件的 task（Job），重启机器的 task（Job），优惠券到期发送短信提醒的 task（Job），实现接口如下：<br>
<img src="https://img-blog.csdn.net/20180710135410275?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>（2）有了任务之后，还需要一个能够实现触发任务去执行的触发器，触发器 Trigger 最基本的功能是指定 Job 的执行时间，执行间隔，运行次数等。<br>
<img src="https://img-blog.csdn.net/20180710135421739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>（3）有了 Job 和 Trigger 后，怎么样将两者结合起来呢？即怎样指定 Trigger 去执行指定的 Job 呢？这时需要一个 Schedule，来负责这个功能的实现。<br>
<img src="https://img-blog.csdn.net/20180710135431806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>上面三个部分就是 Quartz 的基本组成部分：</p>
<ul>
<li>调度器：Scheduler</li>
<li>任务：JobDetail</li>
<li>触发器：Trigger，包括 SimpleTrigger 和 CronTrigger</li>
</ul>
<h2 id="二-quartz-demo-搭建">二、Quartz Demo 搭建</h2>
<p>下面来利用 Quartz 搭建一个最基本的 Demo。<br>
1、导入依赖的 jar 包：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
    &lt;artifactId&gt;quartz&lt;/artifactId&gt;
    &lt;version&gt;2.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、新建一个能够打印任意内容的 Job：</p>
<pre><code class="language-java">/**
 * Created by wanggenshen
 * Date: on 2018/7/7 16:28.
 * Description: 打印任意内容
 */
public class PrintWordsJob implements Job{

    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        String printTime = new SimpleDateFormat(&quot;yy-MM-dd HH-mm-ss&quot;).format(new Date());
        System.out.println(&quot;PrintWordsJob start at:&quot; + printTime + &quot;, prints: Hello Job-&quot; + new Random().nextInt(100));

    }
}
</code></pre>
<p>3、创建 Schedule，执行任务：</p>
<pre><code class="language-java">/**
 * Created by wanggenshen
 * Date: on 2018/7/7 16:31.
 * Description: XXX
 */
public class MyScheduler {

    public static void main(String\[\] args) throws SchedulerException, InterruptedException {
        // 1、创建调度器Scheduler
        SchedulerFactory schedulerFactory = new StdSchedulerFactory();
        Scheduler scheduler = schedulerFactory.getScheduler();
        // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容)
        JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class)
                                        .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();
        // 3、构建Trigger实例,每隔1s执行一次
        Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
                .startNow()//立即生效
                .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                .withIntervalInSeconds(1)//每隔1s执行一次
                .repeatForever()).build();//一直执行

        //4、执行
        scheduler.scheduleJob(jobDetail, trigger);
        System.out.println(&quot;--------scheduler start ! ------------&quot;);
        scheduler.start();

        //睡眠
        TimeUnit.MINUTES.sleep(1);
        scheduler.shutdown();
        System.out.println(&quot;--------scheduler shutdown ! ------------&quot;);


    }
}
</code></pre>
<p>运行程序，可以看到程序每隔 1s 会打印出内容，且在一分钟后结束：<br>
<img src="https://img-blog.csdn.net/20180710135458277?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<h2 id="三-quartz-核心详解">三、Quartz 核心详解</h2>
<p>下面就程序中出现的几个参数，看一下 Quartz 框架中的几个重要参数：</p>
<ul>
<li>Job 和 JobDetail</li>
<li>JobExecutionContext</li>
<li>JobDataMap</li>
<li>Trigger、SimpleTrigger、CronTrigger</li>
</ul>
<p>（1）Job 和 JobDetail<br>
Job 是 Quartz 中的一个接口，接口下只有 execute 方法，在这个方法中编写业务逻辑。<br>
接口中的源码：<br>
<img src="https://img-blog.csdn.net/20180710135513678?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>JobDetail 用来绑定 Job，为 Job 实例提供许多属性：</p>
<ul>
<li>name</li>
<li>group</li>
<li>jobClass</li>
<li>jobDataMap</li>
</ul>
<p>JobDetail 绑定指定的 Job，每次 Scheduler 调度执行一个 Job 的时候，首先会拿到对应的 Job，然后创建该 Job 实例，再去执行 Job 中的 execute() 的内容，任务执行结束后，关联的 Job 对象实例会被释放，且会被 JVM GC 清除。</p>
<p>为什么设计成 JobDetail + Job，不直接使用 Job</p>
<blockquote>
<p>JobDetail 定义的是任务数据，而真正的执行逻辑是在 Job 中。<br>
这是因为任务是有可能并发执行，如果 Scheduler 直接使用 Job，就会存在对同一个 Job 实例并发访问的问题。而 JobDetail &amp; Job 方式，Sheduler 每次执行，都会根据 JobDetail 创建一个新的 Job 实例，这样就可以规避并发访问的问题。</p>
</blockquote>
<p>（2）JobExecutionContext<br>
JobExecutionContext 中包含了 Quartz 运行时的环境以及 Job 本身的详细数据信息。<br>
当 Schedule 调度执行一个 Job 的时候，就会将 JobExecutionContext 传递给该 Job 的 execute() 中，Job 就可以通过 JobExecutionContext 对象获取信息。<br>
主要信息有：<br>
<img src="https://img-blog.csdn.net/20180710135537517?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>（3）JobExecutionContext<br>
JobDataMap 实现了 JDK 的 Map 接口，可以以 Key-Value 的形式存储数据。<br>
JobDetail、Trigger 都可以使用 JobDataMap 来设置一些参数或信息，<br>
Job 执行 execute() 方法的时候，JobExecutionContext 可以获取到 JobExecutionContext 中的信息：<br>
如：</p>
<pre><code class="language-java">JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class)                        .usingJobData(&quot;jobDetail1&quot;, &quot;这个Job用来测试的&quot;)
                  .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();

 Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
      .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)
      .startNow()//立即生效
      .withSchedule(SimpleScheduleBuilder.simpleSchedule()
      .withIntervalInSeconds(1)//每隔1s执行一次
      .repeatForever()).build();//一直执行
</code></pre>
<p>Job 执行的时候，可以获取到这些参数信息：</p>
<pre><code class="language-java">@Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {

        System.out.println(jobExecutionContext.getJobDetail().getJobDataMap().get(&quot;jobDetail1&quot;));
        System.out.println(jobExecutionContext.getTrigger().getJobDataMap().get(&quot;trigger1&quot;));
        String printTime = new SimpleDateFormat(&quot;yy-MM-dd HH-mm-ss&quot;).format(new Date());
        System.out.println(&quot;PrintWordsJob start at:&quot; + printTime + &quot;, prints: Hello Job-&quot; + new Random().nextInt(100));


    }
</code></pre>
<p>（4）Trigger、SimpleTrigger、CronTrigger</p>
<ul>
<li><strong>Trigger</strong></li>
</ul>
<p>Trigger 是 Quartz 的触发器，会去通知 Scheduler 何时去执行对应 Job。</p>
<pre><code>new Trigger().startAt():表示触发器首次被触发的时间;
new Trigger().endAt():表示触发器结束触发的时间;
</code></pre>
<ul>
<li><strong>SimpleTrigger</strong><br>
SimpleTrigger 可以实现在一个指定时间段内执行一次作业任务或一个时间段内多次执行作业任务。<br>
下面的程序就实现了程序运行 5s 后开始执行 Job，执行 Job 5s 后结束执行：</li>
</ul>
<pre><code>Date startDate = new Date();
startDate.setTime(startDate.getTime() + 5000);

 Date endDate = new Date();
 endDate.setTime(startDate.getTime() + 5000);

        Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
                .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)
                .startNow()//立即生效
                .startAt(startDate)
                .endAt(endDate)
                .withSchedule(SimpleScheduleBuilder.simpleSchedule()
                .withIntervalInSeconds(1)//每隔1s执行一次
                .repeatForever()).build();//一直执行
</code></pre>
<ul>
<li><strong>CronTrigger</strong></li>
</ul>
<p>CronTrigger 功能非常强大，是基于日历的作业调度，而 SimpleTrigger 是精准指定间隔，所以相比 SimpleTrigger，CroTrigger 更加常用。CroTrigger 是基于 Cron 表达式的，先了解下 Cron 表达式：<br>
由 7 个子表达式组成字符串的，格式如下：</p>
<blockquote>
<p>[秒] [分] [小时] [日] [月] [周] [年]</p>
</blockquote>
<p>Cron 表达式的语法比较复杂，<br>
如：* 30 10 ? * 1/5 *<br>
表示（从后往前看）<br>
[指定年份] 的 [ 周一到周五][指定月][不指定日][上午 10 时][30 分][指定秒]</p>
<p>又如：00 00 00 ？ * 10,11,12 1#5 2018<br>
表示 2018 年 10、11、12 月的第一周的星期五这一天的 0 时 0 分 0 秒去执行任务。</p>
<p>下面是给的一个例子：<br>
<img src="https://img-blog.csdn.net/20180710135615747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>可通过在线生成 Cron 表达式的工具：<a href="http://cron.qqe2.com/">http://cron.qqe2.com/</a> 来生成自己想要的表达式。<br>
<img src="https://img-blog.csdn.net/20180710135623995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"></p>
<p>下面的代码就实现了每周一到周五上午 10:30 执行定时任务</p>
<pre><code class="language-java">/**
 * Created by wanggenshen
 * Date: on 2018/7/7 20:06.
 * Description: XXX
*/
public class MyScheduler2 {
    public static void main(String\[\] args) throws SchedulerException, InterruptedException {
        // 1、创建调度器Scheduler
        SchedulerFactory schedulerFactory = new StdSchedulerFactory();
        Scheduler scheduler = schedulerFactory.getScheduler();
        // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容)
        JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class)
                .usingJobData(&quot;jobDetail1&quot;, &quot;这个Job用来测试的&quot;)
                .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build();
        // 3、构建Trigger实例,每隔1s执行一次
        Date startDate = new Date();
        startDate.setTime(startDate.getTime() + 5000);

        Date endDate = new Date();
        endDate.setTime(startDate.getTime() + 5000);

        CronTrigger cronTrigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
                .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;)
                .startNow()//立即生效
                .startAt(startDate)
                .endAt(endDate)
                .withSchedule(CronScheduleBuilder.cronSchedule(&quot;\* 30 10 ? \* 1/5 2018&quot;))
                .build();

        //4、执行
        scheduler.scheduleJob(jobDetail, cronTrigger);
        System.out.println(&quot;--------scheduler start ! ------------&quot;);
        scheduler.start();
        System.out.println(&quot;--------scheduler shutdown ! ------------&quot;);

    }
}
</code></pre>
<hr>
<p>2018/07/07 20:10 in SH.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot使用GetMapping时对象作为参数，对象的属性不可以_开头]]></title>
        <id>https://Eakamm.github.io/post/springboot-shi-yong-getmapping-shi-dui-xiang-zuo-wei-can-shu-dui-xiang-de-shu-xing-bu-ke-yi-_-kai-tou/</id>
        <link href="https://Eakamm.github.io/post/springboot-shi-yong-getmapping-shi-dui-xiang-zuo-wei-can-shu-dui-xiang-de-shu-xing-bu-ke-yi-_-kai-tou/">
        </link>
        <updated>2020-09-28T03:35:16.000Z</updated>
        <summary type="html"><![CDATA[<p>SpringBoot使用GetMapping时以对象作为参数，对象的属性不可以_开头，在网上也没有找到解释。</p>
]]></summary>
        <content type="html"><![CDATA[<p>SpringBoot使用GetMapping时以对象作为参数，对象的属性不可以_开头，在网上也没有找到解释。</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js中跳出forEach循环]]></title>
        <id>https://Eakamm.github.io/post/js-zhong-tiao-chu-foreach-xun-huan/</id>
        <link href="https://Eakamm.github.io/post/js-zhong-tiao-chu-foreach-xun-huan/">
        </link>
        <updated>2020-09-27T07:08:57.000Z</updated>
        <summary type="html"><![CDATA[<p>在使用forEach中需要在处理后跳出循环，return和break都无法跳出。经过查找资料后，我找到了两种方法可以实现跳出循环。当然可以使用for循环直接解决🌸🐔</p>
]]></summary>
        <content type="html"><![CDATA[<p>在使用forEach中需要在处理后跳出循环，return和break都无法跳出。经过查找资料后，我找到了两种方法可以实现跳出循环。当然可以使用for循环直接解决🌸🐔</p>
<!-- more -->
<h2 id="1-使用trycatch捕获异常实现">1、使用try···catch捕获异常实现</h2>
<pre><code class="language-javascript">try{
var array = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;];
array.forEach(function(item,index){
	if(item == &quot;third&quot;){
		var a = aaaa;// first second 后就报错，就跳出循环了
		throw new Error(&quot;ending&quot;);//报错，就跳出循环
	}else{
		log(item);
	}
})
}catch(e){
	if(e.message == &quot;ending&quot;){
		log(&quot;结束了&quot;) ;
	}else{
		log(e.message);
	}
}
</code></pre>
<h2 id="2-使用arrsome或者arrevery替代">2、使用arr.some()或者arr.every()替代</h2>
<p>some()当内部return true时跳出整个循环。<br>
some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。</p>
<pre><code class="language-javascript">var arr = [1,2,3,4,5];
var num = 3;
arr.some(function(v){
	if(v == num) {
        // 返回true代表测试通过，结束循环
		return true;
	}
console.log(v);
});
</code></pre>
<p>every()当内部return false时跳出整个循环<br>
every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>
<pre><code class="language-javascript">var arr = [1,2,3,4,5];
var num = 3;
arr.every(function(v){
	if(v == num) {
		return false;
	}else{
		console.log(v);
		return true;
	}
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pandas基础（一）]]></title>
        <id>https://Eakamm.github.io/post/pandas-ji-chu-yi/</id>
        <link href="https://Eakamm.github.io/post/pandas-ji-chu-yi/">
        </link>
        <updated>2020-09-25T06:47:37.000Z</updated>
        <summary type="html"><![CDATA[<p>Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。</p>
<!-- more -->
<h2 id="1-servies">1、Servies</h2>
<p>pandas创建一个一维数组</p>
<pre><code class="language-python{cmd}">import pandas as pd
import numpy as np

s = pd.Series(['a', 'b', 'c'], index=[1, 2, 3])

# 获取索引序列
print(s.index)

# 根据索引查找数据
print(s[1])
s[1] = &quot;e&quot;
print(s[1])

print('----------------------------------')
# 多个索引或值查找
s2 = pd.Series([1, 2, 6], index=['a', 'b', 'c'])
# 自定义的索引('a', 'b', 'c')
print(s2[['a', 'b']])
# 第n行(0,1,2)
print(s2[[1, 2]])
# 值小于等于n
print(s2[s2 &lt;= 3])

print('----------------------------------')
# in判断索引是否存在
print(1 in s)

</code></pre>
<p>通过<code>.index</code>改变索引</p>
<pre><code class="language-python"># Series的索引可以通过按位置赋值的方式进行改变
s.index = ['a','b','c']
</code></pre>
<p>Python切片中是不包含尾部的，Series的自定义字符串索引的切片与之不同.</p>
<pre><code class="language-python">import pandas as pd
import numpy as np

# 字符串索引
s = pd.Series([1,2,3], index=['a', 'b', 'c'])
# 数字索引
s1 = pd.Series([1,2,3], index=[1, 2, 3])
s2 = [1,2,3]
print(s2[0:1])
# 根据行数做切片与普通数组的切片相同
print(s1[1:2])
# 自定义字符串索引包含尾部
print(s['a':'b'])

# 可以使用切片更改数据
s['a':'b'] = 4
print(s)
</code></pre>
<h2 id="2-dataframe">2、DataFrame</h2>
<h3 id="21-创建">2.1、创建</h3>
<p>最常用的方式是利用包含等长度列表或NumPy数组的字典来形成DataFrame(某一列没有赋值，会出现缺省值NaN)</p>
<pre><code class="language-python">import pandas as pd

data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
frame = pd.DataFrame(data)

print(frame)
</code></pre>
<p>设置列名与行名，<code>debt</code>列为空，为NaN</p>
<pre><code class="language-python">&gt;&gt;&gt; frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
...                       index=['one', 'two', 'three', 'four',
...                              'five', 'six'])
&gt;&gt;&gt; frame2
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
six    2003  Nevada  3.2  NaN
</code></pre>
<h3 id="22-查找">2.2、查找</h3>
<p><code>loc[]</code>获取某一行的数据</p>
<pre><code class="language-python">import pandas as pd

data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
frame = pd.DataFrame(data)

# 查找某一行
print(frame)
print(frame.loc[1])

# 多个索引查找


# 创建新的一列
frame['test'] = frame.state == 'Ohio'
print(frame)
# 删除一列
del frame['test']
print(frame.columns)
</code></pre>
<h3 id="23-根据布尔值切片">2.3、根据布尔值切片</h3>
<p>可以根据一个布尔值数组选择数据，也可以比较所有的元素，对符合要求的元素执行操作。</p>
<pre><code class="language-python{cmd}">import pandas as pd
import numpy as np
frame = pd.DataFrame(np.arange(20).reshape(4, 5),
                      index=list('abcd'),
                      columns=list('abcde'))
# frame &lt; 5
print(frame &lt; 5)
# 将小于5的元素改为0
frame[frame &lt; 5] = 0
print(frame)
# 根据列的比较结果显示数据
print(frame[frame['b'] &gt; 10])

print(frame)
</code></pre>
<h3 id="24-loc与iloc索引">2.4、loc与iloc索引</h3>
<p>标签选出单行多列的数据可以使用<code>loc</code>（也就是自定义的索引）</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

frame = pd.DataFrame(np.arange(20).reshape(4, 5),
                      index=list('abcd'),
                      columns=list('abcde'))
# 获取某一行
print(frame.loc['a'])
# 获取某一行的n列数据
print(frame.loc['a',['a', 'b']])
# 
print(frame.loc[['a','b'],['a', 'b']])
</code></pre>
<p>整数标签<code>iloc</code>进行类似的数据选择</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

frame = pd.DataFrame(np.arange(20).reshape(4, 5),
                      index=list('abcd'),
                      columns=list('abcde'))
print(frame.iloc[1])

print(frame.iloc[1,[1,2]])

print(frame.iloc[[1,2],[1,2]])
</code></pre>
<h3 id="25-整数索引问题">2.5、整数索引问题</h3>
<pre><code class="language-python">import numpy as np
import pandas as pd


</code></pre>
<p>当使用字符串的索引就不会对s[-1]产生歧义</p>
<p>所以你有一个包含整数的轴索引，数据选择时请始终使用标签索引。</p>
<h3 id="26-广播机制">2.6、广播机制</h3>
<h3 id="27-函数">2.7、函数</h3>
<p>使用<code>apply</code>可以取出每一行或每一列的元素。<code>axis = 'columns'</code>取出每一行，以行为索引。默认为列。<br>
可以使用函数对数据进行更复杂的操作</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

df = pd.DataFrame(np.arange(20).reshape(4, 5),
                  columns=list('abcde'))

# 求每组数据的最大最小值的差


def f(x): return x.max()-x.min()


# 默认为取出每列
series = df.apply(f)
print(series)

# 取出每行
series = df.apply(f, axis=&quot;columns&quot;)
print(series)
</code></pre>
<p>使用<code>applymap</code>取出每个元素</p>
<pre><code class="language-python">import numpy as np
import pandas as pd

df = pd.DataFrame(np.arange(20).reshape(4, 5),
                  columns=list('abcde'))
# 处理所有的元素
# 求平方
def f2(x): return x**2


data_frame = df.applymap(f2)
print(data_frame)

# 处理某一行
data_frame = df.loc[1].map(f2)
print(data_frame)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用数字正则表达式]]></title>
        <id>https://Eakamm.github.io/post/chang-yong-shu-zi-zheng-ze-biao-da-shi/</id>
        <link href="https://Eakamm.github.io/post/chang-yong-shu-zi-zheng-ze-biao-da-shi/">
        </link>
        <updated>2020-09-11T08:43:37.000Z</updated>
        <content type="html"><![CDATA[<p>验证数字的正则表达式集</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>正则表达式</th>
<th>部分验证的格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>验证数字</td>
<td><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>*$</td>
<td></td>
</tr>
<tr>
<td>验证n位的数字</td>
<td>^\d{n}$</td>
<td></td>
</tr>
<tr>
<td>验证至少n位数字</td>
<td>^\d{n,}$</td>
<td></td>
</tr>
<tr>
<td>验证m-n位的数字</td>
<td>^\d{m,n}$</td>
<td></td>
</tr>
<tr>
<td>验证零和非零开头的数字</td>
<td>^(0</td>
<td>[1-9][0-9]*)$</td>
</tr>
<tr>
<td>验证有两位小数的正实数</td>
<td><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>+(.[0-9]{2})?$</td>
<td></td>
</tr>
<tr>
<td>验证有1-3位小数的正实数</td>
<td><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>+(.[0-9]{1,3})?$</td>
<td></td>
</tr>
<tr>
<td>验证非零的正整数</td>
<td>^+?[1-9][0-9]*$</td>
<td></td>
</tr>
<tr>
<td>验证非零的负整数</td>
<td>^-[1-9][0-9]*$</td>
<td></td>
</tr>
<tr>
<td>验证非负整数（正整数 + 0）</td>
<td>^\d+$</td>
<td></td>
</tr>
<tr>
<td>验证非正整数（负整数 + 0）</td>
<td>^((-\d+)</td>
<td>(0+))$</td>
</tr>
<tr>
<td>验证长度为3的字符</td>
<td>^.{3}$</td>
<td></td>
</tr>
<tr>
<td>验证由26个英文字母组成的字符串</td>
<td><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>+$</td>
<td></td>
</tr>
<tr>
<td>验证由26个大写英文字母组成的字符串</td>
<td><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>+$</td>
<td></td>
</tr>
<tr>
<td>验证由26个小写英文字母组成的字符串</td>
<td><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>+$</td>
<td></td>
</tr>
<tr>
<td>验证由数字和26个英文字母组成的字符串</td>
<td><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>+$</td>
<td></td>
</tr>
<tr>
<td>验证由数字、26个英文字母或者下划线组成的字符串</td>
<td>^\w+$</td>
<td></td>
</tr>
<tr>
<td>验证用户密码</td>
<td><sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>\w{5,17}$</td>
<td>正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。</td>
</tr>
<tr>
<td>验证是否含有 ^%&amp;',;=?$&quot; 等字符</td>
<td>[^%&amp;',;=?$\x22]+</td>
<td></td>
</tr>
<tr>
<td>验证汉字</td>
<td><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>,{0,}$</td>
<td></td>
</tr>
<tr>
<td>验证Email地址</td>
<td>/^([a-zA-Z0-9]+[_</td>
<td>_</td>
</tr>
<tr>
<td>验证InternetURL</td>
<td>^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]<em>)?$ ；<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>+://(w+(-w+)</em>)(.(w+(-w+)<em>))</em>(?S*)?$</td>
<td></td>
</tr>
<tr>
<td>验证电话号码</td>
<td>^(\d3,4\d3,4</td>
<td>\d{3,4}-)?\d{7,8}$</td>
</tr>
<tr>
<td>验证身份证号（15位或18位数字）</td>
<td>^\d{15}</td>
<td>\d{}18$</td>
</tr>
<tr>
<td>验证一年的12个月</td>
<td>^(0?[1-9]</td>
<td>1[0-2])$</td>
</tr>
<tr>
<td>验证一个月的31天</td>
<td>^((0?[1-9])</td>
<td>((1</td>
</tr>
<tr>
<td>整数</td>
<td>^-?\d+$</td>
<td></td>
</tr>
<tr>
<td>非负浮点数（正浮点数 + 0）</td>
<td>^\d+(.\d+)?$</td>
<td></td>
</tr>
<tr>
<td>正浮点数</td>
<td>^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)</td>
<td>([0-9]<em>[1-9][0-9]</em>.[0-9]+)</td>
</tr>
<tr>
<td>非正浮点数</td>
<td>（负浮点数 + 0） ^((-\d+(.\d+)?)</td>
<td>(0+(.0+)?))$</td>
</tr>
<tr>
<td>负浮点数</td>
<td>^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)</td>
<td>([0-9]<em>[1-9][0-9]</em>.[0-9]+)</td>
</tr>
<tr>
<td>浮点数</td>
<td>^(-?\d+)(.\d+)?$</td>
<td></td>
</tr>
</tbody>
</table>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>0-9 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>0-9 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>0-9 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>A-Za-z <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>A-Z <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>a-z <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>A-Za-z0-9 <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>a-zA-Z <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>\u4e00-\u9fa5 <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>a-zA-z <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JWT]]></title>
        <id>https://Eakamm.github.io/post/jwt/</id>
        <link href="https://Eakamm.github.io/post/jwt/">
        </link>
        <updated>2020-09-08T09:15:57.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（<a href="https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc7519">(RFC 7519</a>). 该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（<a href="https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc7519">(RFC 7519</a>). 该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p>
</blockquote>
<!-- more -->
<h2 id="原文地址-wwwjianshucomhttpswwwjianshucomp576dbf44b2ae起源">原文地址 [www.jianshu.com](https://www.jianshu.com/p/576dbf44b2ae)<br>
起源</h2>
<p>说起 JWT，我们应该来谈一谈基于 token 的认证和传统的 session 认证的区别。</p>
<h3 id="传统的-session-认证">传统的 session 认证</h3>
<p>我们知道，http 协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据 http 协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为 cookie, 以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了, 这就是传统的基于 session 认证。</p>
<p>但是这种基于 session 的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于 session 认证应用的问题就会暴露出来.</p>
<h4 id="基于-session-认证所显露的问题">基于 session 认证所显露的问题</h4>
<p><strong>Session</strong>: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言 session 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p>
<p><strong>扩展性</strong>: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上, 这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p>
<p><strong>CSRF</strong>: 因为是基于 cookie 来进行用户识别的, cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h2 id="基于-token-的鉴权机制">基于 token 的鉴权机制</h2>
<p>基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>流程上是这样的：</p>
<ul>
<li>用户使用用户名密码来请求服务器</li>
<li>服务器进行验证用户的信息</li>
<li>服务器通过验证发送给用户一个 token</li>
<li>客户端存储 token，并在每次请求时附送上这个 token 值</li>
<li>服务端验证 token 值，并返回数据</li>
</ul>
<p>这个 token 必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p>
<p>那么我们现在回到 JWT 的主题上。</p>
<h2 id="jwt-长什么样">JWT 长什么样？</h2>
<p>JWT 是由三段信息构成的，将这三段信息文本用<code>.</code>链接一起就构成了 Jwt 字符串。就像这样:</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>
<h2 id="jwt-的构成">JWT 的构成</h2>
<p>第一部分我们称它为头部（header), 第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).</p>
<h3 id="header">header</h3>
<p>jwt 的头部承载两部分信息：</p>
<ul>
<li>声明类型，这里是 jwt</li>
<li>声明加密的算法 通常直接使用 HMAC SHA256</li>
</ul>
<p>完整的头部就像下面这样的 JSON：</p>
<pre><code>{
  'typ': 'JWT',
  'alg': 'HS256'
}
</code></pre>
<p>然后将头部进行 base64 加密（该加密是可以对称解密的), 构成了第一部分.</p>
<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
</code></pre>
<h3 id="playload">playload</h3>
<p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>标准中注册的声明</strong> (建议但不强制使用) ：</p>
<ul>
<li><strong>iss</strong>: jwt 签发者</li>
<li><strong>sub</strong>: jwt 所面向的用户</li>
<li><strong>aud</strong>: 接收 jwt 的一方</li>
<li><strong>exp</strong>: jwt 的过期时间，这个过期时间必须要大于签发时间</li>
<li><strong>nbf</strong>: 定义在什么时间之前，该 jwt 都是不可用的.</li>
<li><strong>iat</strong>: jwt 的签发时间</li>
<li><strong>jti</strong>: jwt 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。</li>
</ul>
<p><strong>公共的声明</strong> ：<br>
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 但不建议添加敏感信息，因为该部分在客户端可解密.</p>
<p><strong>私有的声明</strong> ：<br>
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>定义一个 payload:</p>
<pre><code>{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}
</code></pre>
<p>然后将其进行 base64 加密，得到 Jwt 的第二部分。</p>
<pre><code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
</code></pre>
<h3 id="signature">signature</h3>
<p>jwt 的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64 后的)</li>
<li>payload (base64 后的)</li>
<li>secret</li>
</ul>
<p>这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用<code>.</code>连接组成的字符串，然后通过 header 中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了 jwt 的第三部分。</p>
<pre><code>// javascript
var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);

var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>
<p>将这三部分用<code>.</code>连接成一个完整的字符串, 构成了最终的 jwt:</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>
<p><strong>注意：secret 是保存在服务器端的，jwt 的签发生成也是在服务器端的，secret 就是用来进行 jwt 的签发和 jwt 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个 secret, 那就意味着客户端是可以自我签发 jwt 了。</strong></p>
<h3 id="如何应用">如何应用</h3>
<p>一般是在请求头里加入<code>Authorization</code>，并加上<code>Bearer</code>标注：</p>
<pre><code>fetch('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
</code></pre>
<p>服务端会验证 token，如果验证通过就会返回相应的资源。整个流程就是这样的:</p>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/1821058-2e28fe6c997a60c9.png" alt="" loading="lazy"></figure>
<p>jwt-diagram</p>
<h2 id="总结">总结</h2>
<h3 id="优点">优点</h3>
<ul>
<li>因为 json 的通用性，所以 JWT 是可以进行跨语言支持的，像 JAVA,JavaScript,NodeJS,PHP 等很多语言都可以使用。</li>
<li>因为有了 payload 部分，所以 JWT 可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li>
<li>便于传输，jwt 的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>
<li>它不需要在服务端保存会话信息, 所以它易于应用的扩展</li>
</ul>
<h3 id="安全相关">安全相关</h3>
<ul>
<li>不应该在 jwt 的 payload 部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>保护好 secret 私钥，该私钥非常重要。</li>
<li>如果可以，请使用 https 协议</li>
</ul>
<figure data-type="image" tabindex="2"><a href="https://www.jianshu.com/u/d286ee5ad51e"><img src="https://upload.jianshu.io/users/upload_avatars/1821058/f2a247ca2423?imageMogr2/auto-orient/strip%7CimageView2/1/w/100/h/100/format/webp" alt="" loading="lazy"></a></figure>
<p><a href="https://www.jianshu.com/u/d286ee5ad51e" title="Dearmadman">Dearmadman</a>Beautiful work by passionate people.</p>
<p>总资产 17 (约 1.56 元) 共写了 11.1W 字获得 1,289 个赞共 932 个粉丝</p>
<h3 id="被以下专题收入发现更多相似内容">被以下专题收入，发现更多相似内容</h3>
<h3 id="推荐阅读更多精彩内容">推荐阅读<a href="https://www.jianshu.com/">更多精彩内容</a></h3>
<ul>
<li>
<p>1. 微服务架构介绍 1.1 什么是微服务架构？ 形像一点来说，微服务架构就像搭积木，每个微服务都是一个零件，并使...</p>
<p><a href="https://www.jianshu.com/u/d6e5ad19fcef"><img src="https://cdn2.jianshu.io/assets/default_avatar/10-e691107df16746d4a9f3fe9496fd1848.jpg" alt="" loading="lazy">静修佛缘</a>阅读 28</p>
<figure data-type="image" tabindex="3"><a href="https://www.jianshu.com/p/15d0a1c366b3"><img src="https://upload-images.jianshu.io/upload_images/1775814-8884b980e74daa5b?imageMogr2/auto-orient/strip%7CimageView2/1/w/300/h/240/format/webp" alt="" loading="lazy"></a></figure>
</li>
<li>
<p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智...</p>
<figure data-type="image" tabindex="4"><a href="https://www.jianshu.com/p/46fd0faecac1"><img src="https://upload-images.jianshu.io/upload_images/7328262-54f7992145380c10.png?imageMogr2/auto-orient/strip%7CimageView2/1/w/300/h/240/format/webp" alt="" loading="lazy"></a></figure>
</li>
<li>
<p>注：参考 Spring Security 整合 JSON Web Token(JWT) 提升 REST 安全性，写的...</p>
<figure data-type="image" tabindex="5"><a href="https://www.jianshu.com/p/beea4bc9056b"><img src="https://upload-images.jianshu.io/upload_images/3145530-7a18f4fd40be4d85.png?imageMogr2/auto-orient/strip%7CimageView2/1/w/300/h/240/format/webp" alt="" loading="lazy"></a></figure>
</li>
</ul>
]]></content>
    </entry>
</feed>