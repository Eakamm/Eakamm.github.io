{"posts":[{"title":"windows注册系统服务（实现开机自启）","content":"1、nginx 我们借助 Windows Service Wrapper 小工具，将 Nginx 转换为 Windows 服务，在服务中心配置自启动，从而在开机时 windows 自行启动 Nginx 服务。 1、自启动工具下载 工具下载 URL：https://github.com/winsw/winsw/releases 如下图，为windows32位和64位的工具文件 上面 github 需要外网访问比较快，没有外网的同学们，我也给你们下好了，自行下载吧~ 32 位：WinSW-x86.exe （提取码：0915） 64 位：WinSW-x64.exe （提取码：0915） 2、自启动工具安装 步骤一：下载后将该工具放入 Nginx 的安装目录下，并且将其重命名为 nginx-service.exe ； 步骤二：在 nginx 安装目录下新建服务日志文件夹 server-logs 文件夹, 用来存放 nginx 服务相关日志。 步骤三：在该目录下新建 nginx-service.xml 文件，写入配置信息，配置好了之后就可以通过这个将 Nginx 注册为 Windows 服务了。 文件配置内容如下：重点包括三个，日志文件位置、启动命令、关闭命令；我 nginx 目录为：D:\\work\\nginx\\nginx-1.18.0，同学们根据自己的目录作相应修改。 &lt;!-- nginx-service.xml --&gt; &lt;service&gt; &lt;id&gt;nginx&lt;/id&gt; &lt;name&gt;nginx&lt;/name&gt; &lt;description&gt;nginx&lt;/description&gt; &lt;logpath&gt;D:\\work\\nginx\\nginx-1.18.0\\server-logs\\&lt;/logpath&gt; &lt;logmode&gt;roll&lt;/logmode&gt; &lt;depend&gt;&lt;/depend&gt; &lt;executable&gt;D:\\work\\nginx\\nginx-1.18.0\\nginx.exe&lt;/executable&gt; &lt;stopexecutable&gt;D:\\work\\nginx\\nginx-1.18.0\\nginx.exe -s stop&lt;/stopexecutable&gt; &lt;/service&gt; 3、把 nginx 加入到 windows 服务中 以上内容配置好了之后，在 nginx 安装目录下以管理员运行命令：.\\nginx-service.exe install 就成功将其注册为 Windows 服务了。这时我们就可以在 Windows 任务管理器的服务中查看到 nginx 服务了。 后续修改 windows 服务的流程同学们应该都清楚了，将启动方式改成自动即可； 然后启动 nginx 服务 启动后通过http://localhost:80 或 命令 tasklist /fi &quot;imagename eq nginx.exe&quot; 检查是否启动成功 附：工具其他命令 效果命令注册系统服务命令nginx-service.exe install删除已注册的系统服务命令nginx-service.exe uninstall停止对应的系统服务命令nginx-service.exe stop启动对应的系统服务命令nginx-service.exe start 2、Java项目 1. 下载 winsw.exe 和. xml(注意：可能需要安装 .net framework4) 地址：https://github.com/winsw/winsw/releases 2. 与 jar 包同路径，同名，改名. exe 与. xml 并配置 xxx.xml 配置说明 :https://github.com/kohsuke/winsw/blob/master/doc/xmlConfigFile.md 我的配置: &lt;service&gt; &lt;!-- ID of the service. It should be unique accross the Windows system--&gt; &lt;!--服务ID：启动、关闭、删除服务时，都是通过ID来操作的--&gt; &lt;id&gt;file-service&lt;/id&gt; &lt;!-- Display name of the service --&gt; &lt;name&gt;file-service&lt;/name&gt; &lt;!-- Service description --&gt; &lt;description&gt;fileservice&lt;/description&gt; &lt;!-- Path to the executable, which should be started --&gt; &lt;!--当前电脑配置了java环境变量，直接写成“java”就行；你也可以写成类似这样：D:\\develop\\jdk1.8\\jre\\bin\\java--&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;!--&lt;arguments&gt;-jar &quot;C:\\Users\\Administrator\\Desktop\\winsw\\statement-0.0.1-SNAPSHOT.jar&quot;&lt;/arguments&gt;--&gt; &lt;arguments&gt;-jar file-service.jar -Xms512M -Xmx512M&lt;/arguments&gt; &lt;!-- OPTION: onfailure Defines a sequence of actions, which should be performed if the managed executable fails. Supported actions: restart, reboot, none --&gt; &lt;onfailure action=&quot;restart&quot; delay=&quot;10 sec&quot;/&gt; &lt;onfailure action=&quot;restart&quot; delay=&quot;20 sec&quot;/&gt; &lt;!-- OPTION: resetfailure Time, after which the Windows service resets the failure status. Default value: 1 day --&gt; &lt;resetfailure&gt;1 hour&lt;/resetfailure&gt; &lt;!-- OPTION: priority Desired process priority. Possible values: Normal, Idle, High, RealTime, BelowNormal, AboveNormal Default value: Normal --&gt; &lt;priority&gt;Normal&lt;/priority&gt; &lt;!-- OPTION: stoptimeout Time to wait for the service to gracefully shutdown the executable before we forcibly kill it Default value: 15 seconds --&gt; &lt;stoptimeout&gt;15 sec&lt;/stoptimeout&gt; &lt;!-- OPTION: stopparentprocessfirst If set, WinSW will terminate the parent process before stopping the children. Default value: false --&gt; &lt;stopparentprocessfirst&gt;false&lt;/stopparentprocessfirst&gt; &lt;!-- OPTION: startmode Defines start mode of the service. Supported modes: Automatic, Manual, Boot, System (latter ones are supported for driver services only) Default mode: Automatic --&gt; &lt;startmode&gt;Automatic&lt;/startmode&gt; &lt;waithint&gt;15 sec&lt;/waithint&gt; &lt;sleeptime&gt;1 sec&lt;/sleeptime&gt; &lt;log mode=&quot;roll-by-size&quot;&gt; &lt;sizeThreshold&gt;10240&lt;/sizeThreshold&gt; &lt;keepFiles&gt;8&lt;/keepFiles&gt; &lt;/log&gt; &lt;/service&gt; 3.cmd 命令行，输入 xxx.exe install 安装服务 如果权限不足，需要进入 c:\\windows\\System32 目录下，用管理员权限运行 cmd 4.net start xxx 启动服务 net stop xxx 关闭服务 sc delete xxx 删除服务 参考资料: https://blog.csdn.net/lee008108/article/details/78713385 https://blog.csdn.net/Pruett/article/details/92813229 ","link":"https://Eakamm.github.io/post/windows-zhu-ce-xi-tong-fu-wu-shi-xian-kai-ji-zi-qi/"},{"title":"ElementUI 树形控件使用setCheckedKeys未定义","content":"问题： &lt;el-dialog :title=&quot;title&quot; :visible.sync=&quot;open&quot; width=&quot;800px&quot; append-to-body&gt; &lt;el-tree :data=&quot;deptOptions&quot; :props=&quot;defaultProps&quot; :expand-on-click-node=&quot;false&quot; :filter-node-method=&quot;filterNode&quot; show-checkbox node-key=&quot;id&quot; ref=&quot;tree&quot; default-expand-all @check=&quot;handleNodeClick&quot; /&gt; &lt;/el-dialog&gt; 当点击新增时候，因为this.dialogVisible = true时并没有立即更新dom，而是等整个逻辑执行完后再一次新渲染，因此此时的弹框并未渲染，在dom树中是不存在的，this.$refs.tree is undefined的所以setCheckedKeys肯定也是undefined。 handleUpdate(row) { this.reset(); this.getTreeselect(); const id = row.id || this.ids getVoteRole(id).then(response =&gt; { this.form = response.data; let treeSelectKey = []; this.form.workVoteUsers.forEach( user =&gt; { treeSelectKey.push(user.userId) }) this.open = true; this.title = &quot;修改投票角色&quot;; this.setCheckedKeys() }); }, setCheckedKeys(){ console.log(this.$refs.tree) } 解决方法: this.$nextTick()，this.$nextTick()会在dom更新之后在执行回调： opetation (auth) { this.dialogVisible = true this.$nextTick(function() { this.$refs.tree.setCheckedKeys(auth) }) } ","link":"https://Eakamm.github.io/post/elementui-shu-xing-kong-jian-shi-yong-setcheckedkeys-wei-ding-yi/"},{"title":"Vue监听全部属性变化","content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 问题： 在 vue 项目中，现在遇到这样一个问题; 从父组件接受一个对象 obj1，并将这个对象赋值给子组件的 obj2；obj2 是一个表单的各项值，在开始的时候，我是通过 watch 监听整个 obj2 的变化，要获取 obj2 的值；但是现在我接受从父组件传递过来的 obj1 值时；只是在第一次赋值的时候，监听到了 obj2 的变化，当我更改里面属性的时候，后来发现我是对整个 obj2 进行监听（因为 obj2 已经通过了（ Vue.set(object, key, value) 方法向嵌套对象添加响应式属性），所以这里只会监听里面属性的增加和减少（），并不会对属性的值更改进行监听； 显而易见： 我需要重新监听一个对象里面每一个属性值的变化： 查阅资料发现：watch 中的这两个选项deep、immediate 选项：deep 在选项参数中指定 deep: true，可以监听对象中属性的变化。 选项：immediate 在选项参数中指定 immediate: true, 将立即以表达式的当前值触发回调，也就是立即触发一次。 watch: { obj: { handler(val, oldVal) { console.log('属性发生变化触发这个回调',val, oldVal); }, deep: true // 监听这个对象中的每一个属性变化 }, step: { // 属性 //watch handler(val, oldVal) { console.log(&quot;默认立即触发一次&quot;, val, oldVal); }, immediate: true // 默认立即触发一次 }, }, ","link":"https://Eakamm.github.io/post/vue-jian-ting-quan-bu-shu-xing-bian-hua/"},{"title":"定时任务常用CRON表达式","content":"系统中通常有些需要自动执行的任务，这些任务可能每隔一段时间就要执行一次，也可能需要在指定的时间点自动执行，这些任务的自定执行必须使用任务的自动调度。 Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net Cron 表达式是一个字符串，字符串以 5 或 6 个空格隔开，分为 6 或 7 个域，每一个域代表一个含义 格式： Seconds Minutes Hours DayofMonth Month DayofWeek Year Seconds Minutes Hours DayofMonth Month DayofWeek 结构 Corn 从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 字段含义 字段允许值允许的特殊字符秒（Seconds）0~59 的整数, - * / 四个字符分（Minutes）0~59 的整数, - * / 四个字符小时（Hours）0~23 的整数, - * / 四个字符日期（DayofMonth）1~31 的整数（但是你需要考虑你月的天数）,- * ? / L W C 八个字符月份（Month）1~12 的整数或者 JAN-DEC, - * / 四个字符星期（DayofWeek）1~7 的整数或者 SUN-SAT （1=SUN）, - * ? / L C # 八个字符年 (可选，留空)（Year）1970~2099, - * / 四个字符 下面为每周一上午 10 点 15 分执行任务 0 15 10 ? * MON 每月 10 号 9 点 15 分钟执行任务 0 15 9 10 * ? 其它规则附录表 表示式说明\"0 0 12 * * ?\"每天 12 点运行\"0 15 10 ? * *\"每天 10:15 运行\"0 15 10 * * ?\"每天 10:15 运行\"0 15 10 * * ? *\"每天 10:15 运行\"0 15 10 * * ? 2008\"在 2008 年的每天 10：15 运行\"0 * 14 * * ?\"每天 14 点到 15 点之间每分钟运行一次，开始于 14:00，结束于 14:59。\"0 0/5 14 * * ?\"每天 14 点到 15 点每 5 分钟运行一次，开始于 14:00，结束于 14:55。\"0 0/5 14,18 * * ?\"每天 14 点到 15 点每 5 分钟运行一次，此外每天 18 点到 19 点每 5 钟也运行一次。\"0 0-5 14 * * ?\"每天 14:00 点到 14:05，每分钟运行一次。\"0 10,44 14 ? 3 WED\"3 月每周三的 14:10 分到 14:44，每分钟运行一次。\"0 15 10 ? * MON-FRI\"每周一，二，三，四，五的 10:15 分运行。\"0 15 10 15 * ?\"每月 15 日 10:15 分运行。\"0 15 10 L * ?\"每月最后一天 10:15 分运行。\"0 15 10 ? * 6L\"每月最后一个星期五 10:15 分运行。\"0 15 10 ? * 6L 2007-2009\"在 2007,2008,2009 年每个月的最后一个星期五的 10:15 分运行。\"0 15 10 ? * 6#3\"每月第三个星期五的 10:15 分运行。 最后，推荐一个 cron 表达式生成器： http://cron.qqe2.com/ ","link":"https://Eakamm.github.io/post/ding-shi-ren-wu-chang-yong-cron-biao-da-shi/"},{"title":"Mybatis使用collection时一对多分页问题","content":"&lt;resultMap type=&quot;BaseQuestion&quot; id=&quot;BaseQuestionResult&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot; /&gt; &lt;result property=&quot;typeId&quot; column=&quot;type_id&quot; /&gt; &lt;result property=&quot;typeName&quot; column=&quot;type_name&quot; /&gt; &lt;result property=&quot;stem&quot; column=&quot;stem&quot; /&gt; &lt;result property=&quot;count&quot; column=&quot;count&quot; /&gt; &lt;result property=&quot;alloption&quot; column=&quot;alloption&quot; /&gt; &lt;result property=&quot;answer&quot; column=&quot;answer&quot; /&gt; &lt;result property=&quot;deleted&quot; column=&quot;question_deleted&quot; /&gt; &lt;result property=&quot;time&quot; column=&quot;time&quot; /&gt; &lt;result property=&quot;uptime&quot; column=&quot;uptime&quot; /&gt; &lt;result property=&quot;siteId&quot; column=&quot;site_id&quot; /&gt; &lt;collection property=&quot;options&quot; ofType=&quot;StudyQuestionOptions&quot; select=&quot;selectBaseQuestionOptionsList&quot; column=&quot;{questionId=id}&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;option_id&quot; /&gt; &lt;result property=&quot;questionId&quot; column=&quot;question_id&quot; /&gt; &lt;result property=&quot;value&quot; column=&quot;value&quot; /&gt; &lt;result property=&quot;label&quot; column=&quot;label&quot; /&gt; &lt;result property=&quot;deleted&quot; column=&quot;option_deleted&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt; ","link":"https://Eakamm.github.io/post/mybatis-shi-yong-collection-shi-yi-dui-duo-fen-ye-wen-ti/"},{"title":"Mysql常用时间查询","content":"时间查询 1、时间段查询 -- 今天 select fullName,addedTime from t_user where to_days(addedTime) &lt;= to_days(now()); -- 昨天 select fullName,addedTime from t_user where to_days(NOW()) - TO_DAYS(addedTime) &lt;= 1; -- 近7天 select fullName,addedTime from t_user where date_sub(CURDATE(),INTERVAL 7 DAY) &lt;= DATE(addedTime); -- 近30天 SELECT fullName,addedTime FROM t_user where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(addedTime); -- 本月 SELECT fullName,addedTime FROM t_user WHERE DATE_FORMAT( addedTime, '%Y%m' ) = DATE_FORMAT( CURDATE() , '%Y%m' ); -- 上一月 SELECT fullName,addedTime FROM t_user WHERE PERIOD_DIFF( date_format( now( ) , '%Y%m' ) , date_format( addedTime, '%Y%m' ) ) =1; -- 查询本季度数据 select fullName,addedTime FROM t_user where QUARTER(addedTime)=QUARTER(now()); -- 查询上季度数据 select fullName,addedTime FROM t_user where QUARTER(addedTime)=QUARTER(DATE_SUB(now(),interval 1 QUARTER)); -- 查询本年数据 select fullName,addedTime FROM t_user where YEAR(addedTime)=YEAR(NOW()); -- 查询上年数据 select fullName,addedTime FROM t_user where year(addedTime)=year(date_sub(now(),interval 1 year)); -- 查询距离当前现在6个月的数据 select fullName,addedTime FROM t_user where addedTime between date_sub(now(),interval 6 month) and now(); -- 查询当前这周的数据 SELECT fullName,addedTime FROM t_user WHERE YEARWEEK(date_format(addedTime,'%Y-%m-%d')) = YEARWEEK(now()); -- 查询上周的数据 SELECT fullName,addedTime FROM t_user WHERE YEARWEEK(date_format(addedTime,'%Y-%m-%d')) = YEARWEEK(now())-1; -- 查询上个月的数据 select fullName,addedTime FROM t_user where date_format(addedTime,'%Y-%m')=date_format(DATE_SUB(curdate(), INTERVAL 1 MONTH),'%Y-%m'); -- 查询当前月份的数据 select fullName,addedTime FROM t_user where DATE_FORMAT(addedTime,'%Y%m') = DATE_FORMAT(CURDATE(),'%Y%m'); select fullName,addedTime FROM t_user where date_format(addedTime,'%Y-%m')=date_format(now(),'%Y-%m'); -- 查询指定时间段的数据 select fullName,addedTime FROM t_user where addedTime between '2017-1-1 00:00:00' and '2018-1-1 00:00:00'; select fullName,addedTime FROM t_user where addedTime &gt;='2017-1-1 00:00:00' and addedTime &lt; '2018-1-1 00:00:00'; 2、时间分组查询 1、查询方式 &lt;!-- 按日查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%m-%d') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按月查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%m') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按年查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按周查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%u') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time 2、时间格式化规则 DATE_FORMAT(date,format) 根据format字符串格式化date值。下列修饰符可以被用在format字符串中： 符号 描述 %M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”。 ","link":"https://Eakamm.github.io/post/mysql-chang-yong-shi-jian-cha-xun/"},{"title":"XML中不能出现<,导致Mybatis的Mapper无法使用sql的<","content":"在进行项目开发的时候，使用如下sql &lt;select id=&quot;selectIntersectTime&quot; parameterType=&quot;TbPurchaseTime&quot; resultMap=&quot;TbPurchaseTimeResult&quot;&gt; select * from tb_purchase_time where (start_time &gt; #{purchaseStartTime} AND start_time &lt; #{purchaseEndTime}) OR (start_time &lt;= #{purchaseStartTime} AND end_time &gt;= #{purchaseEndTime}) OR (end_time &gt; #{purchaseStartTime} AND end_time &lt; #{purchaseEndTime}) &lt;/select&gt; 小于号会报错 Error creating document instance. Cause: org.xml.sax.SAXParseException; lineNumber: 39; columnNumber: 64; 元素内容必须由格式正确的字符数据或标记组成。 在mybatis中sql是写在xml映射文件中的，如果sql中有一些特殊字符的话，在解析xml文件的时候就会被转义，如若不希望被转义，那该怎么办呢？ 方法一：使用特殊转义字符 例如，&gt;=开始日期 并且&lt;=结束日期 &amp;gt; &gt; 大于号 &amp;lt; &lt; 小于号 &lt;select id=&quot;selectIntersectTime&quot; parameterType=&quot;TbPurchaseTime&quot; resultMap=&quot;TbPurchaseTimeResult&quot;&gt; select * from tb_purchase_time where (start_time &gt; #{purchaseStartTime} AND start_time &amp;lt; #{purchaseEndTime}) OR (start_time &amp;lt;= #{purchaseStartTime} AND end_time &gt;= #{purchaseEndTime}) OR (end_time &gt; #{purchaseStartTime} AND end_time &amp;lt; #{purchaseEndTime}) &lt;/select&gt; 方法二：使用<![CDATA[ ]]>符号 这里面的内容将不被解析 &lt;select id=&quot;selectIntersectTime&quot; parameterType=&quot;TbPurchaseTime&quot; resultMap=&quot;TbPurchaseTimeResult&quot;&gt; select * from tb_purchase_time where (start_time &gt; #{purchaseStartTime} AND start_time &lt;![CDATA[&lt;]]&gt; #{purchaseEndTime}) OR (start_time &lt;![CDATA[&lt;=]]&gt; #{purchaseStartTime} AND end_time &gt;= #{purchaseEndTime}) OR (end_time &gt; #{purchaseStartTime} AND end_time &lt;![CDATA[&lt;]]&gt; #{purchaseEndTime}) &lt;/select&gt; ","link":"https://Eakamm.github.io/post/xml-zhong-bu-neng-chu-xian-lessdao-zhi-mybatis-de-mapper-wu-fa-shi-yong-sql-de-less/"},{"title":"Sql 尽量避免使用IN或NOT IN","content":" 本文由 简悦 SimpRead 转码， 原文地址 www.cnblogs.com WHY？ ==== IN 和 NOT IN 是比较常用的关键字，为什么要尽量避免呢？ 1、效率低 可以参看我之前遇到的一个例子（[小问题笔记（九）] SQL 语句 Not IN 效率低，用 NOT EXISTS 试试） 2、容易出现问题，或查询结果有误 （不能更严重的缺点） 以 IN 为例。建两个表：test1 和 test2 create table test1 (id1 int) create table test2 (id2 int) insert into test1 (id1) values (1),(2),(3) insert into test2 (id2) values (1),(2) 我想要查询，在 test2 中存在的 test1 中的 id 。使用 IN 的一般写法是： select id1 from test1 where id1 in (select id2 from test2) 结果是： OK 木有问题！ 但是如果我一时手滑，写成了： select id1 from test1 where id1 in (select id1 from test2) 不小心把 id2 写成 id1 了 ，会怎么样呢? 结果是： EXCUSE ME！ 为什么不报错？ 单独查询 select id1 from test2 是一定会报错: 消息 207，级别 16，状态 1，第 11 行 列名'id1' 无效。 然而使用了 IN 的子查询就是这么敷衍，直接查出 1 2 3 这仅仅是容易出错的情况，自己不写错还没啥事儿，下面来看一下 NOT IN 直接查出错误结果的情况： 给 test2 插入一个空值： insert into test2 (id2) values (NULL) 我想要查询，在 test2 中不存在的 test1 中的 id 。 select id1 from test1 where id1 not in (select id2 from test2) 结果是： 空白！ 显然这个结果不是我们想要的。我们想要 3。为什么会这样呢？ 原因是：NULL 不等于任何非空的值啊！如果 id2 只有 1 和 2， 那么 3&lt;&gt;1 且 3&lt;&gt;2 所以 3 输出了，但是 id2 包含空值，那么 3 也不等于 NULL 所以它不会输出。 （跑题一句：建表的时候最好不要允许含空值，否则问题多多。） HOW？ 1、用 EXISTS 或 NOT EXISTS 代替 select * from test1 where EXISTS (select * from test2 where id2 = id1 ) select * FROM test1 where NOT EXISTS (select * from test2 where id2 = id1 ) 2、用 JOIN 代替 select id1 from test1 INNER JOIN test2 ON id2 = id1 select id1 from test1 LEFT JOIN test2 ON id2 = id1 where id2 IS NULL 妥妥的没有问题了！ PS：那我们死活都不能用 IN 和 NOT IN 了么？并没有，一位大神曾经说过，如果是确定且有限的集合时，可以使用。如 IN （0，1，2）。 转发自：http://www.cnblogs.com/hydor/p/5391556.html ","link":"https://Eakamm.github.io/post/sql-jin-liang-bi-mian-shi-yong-in-huo-not-in/"},{"title":"SQL编写技巧","content":"1、使用union代替or 力扣习题：595. 大的国家 union将查询的结果合并到一起，会去重，重复数据只会出现一次。 union all 将结果全部列出 原始数据 -- websites +----+--------------+---------------------------+-------+---------+ | id | name | url | alexa | country | +----+--------------+---------------------------+-------+---------+ | 1 | Google | https://www.google.cm/ | 1 | USA | | 2 | 淘宝 | https://www.taobao.com/ | 13 | CN | | 3 | 菜鸟教程 | http://www.runoob.com/ | 4689 | CN | | 4 | 微博 | http://weibo.com/ | 20 | CN | | 5 | Facebook | https://www.facebook.com/ | 3 | USA | | 7 | stackoverflow | http://stackoverflow.com/ | 0 | IND | +----+---------------+---------------------------+-------+---------+ -- apps +----+------------+-------------------------+---------+ | id | app_name | url | country | +----+------------+-------------------------+---------+ | 1 | QQ APP | http://im.qq.com/ | CN | | 2 | 微博 APP | http://weibo.com/ | CN | | 3 | 淘宝 APP | https://www.taobao.com/ | CN | +----+------------+-------------------------+---------+ union SELECT country FROM Websites UNION SELECT country FROM apps union all SELECT country FROM Websites UNION ALL SELECT country FROM apps ","link":"https://Eakamm.github.io/post/sql-bian-xie-ji-qiao/"},{"title":"Lombok的坑大小写问题","content":"在我使用post请求提交数据的时候，使用@Data注释的实体类set方法不能正常使用，通过查找资料发现是大小写问题。 我Post提交的请求数据是 { &quot;vId&quot;: 1, &quot;dIds&quot;: [6,7] } 后端的实体类为VoteDetailRelVo，使用了@Data注解。 @Data public class VoteDetailRelVo { private Long vId; private List&lt;Long&gt; dIds; } lombok自动生成的get/set方法变为了getVId/setVId与getDIds/setDIds。 一般JavaBean属性以小写字母开头，驼峰命名格式，相应的 getter/setter 方法是 get/set 接上首字母大写的属性名。例如：属性名为userName，其对应的getter/setter 方法是 getUserName/setUserName。 但是，还有一些特殊情况： 1、如果属性名的第二个字母大写，那么该属性名直接用作 getter/setter 方法中 get/set 的后部分，就是说大小写不变。例如属性名为uName，方法是getuName/setuName。 2、如果前两个字母是大写（一般的专有名词和缩略词都会大写），也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为URL，方法是getURL/setURL。 3、如果首字母大写，也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为Name，方法是getName/setName，这种是最糟糕的情况，会找不到属性出错，因为默认的属性名是name。 所以Lombok生成的的get/set方法会出现问题。 详解可见https://www.cnblogs.com/sunTin/p/7172932.html ","link":"https://Eakamm.github.io/post/lombok-de-keng-da-xiao-xie-wen-ti/"},{"title":"Java 常用时间比较方式","content":"本文将描述在java中进行日期时间比较的4种方法 本文地址： &gt; 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [c.lanmit.com](https://c.lanmit.com/bianchengkaifa/Java/59964.html) 本文将为您描述在 java 中进行日期时间比较的 4 种方法, 教程操作步骤: Date.compareTo（） java.util.Date提供了在 Java 中比较两个日期的经典方法 compareTo（）。 如果两个日期相等，则返回值为 0。 如果 Date 在 date 参数之后，则返回值大于 0。 如果 Date 在 date 参数之前，则返回值小于 0。 @Test void testDateCompare() throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date1 = sdf.parse(&quot;2009-12-31&quot;); Date date2 = sdf.parse(&quot;2019-01-31&quot;); System.out.println(&quot;date1 : &quot; + sdf.format(date1)); System.out.println(&quot;date2 : &quot; + sdf.format(date2)); if (date1.compareTo(date2) &gt; 0) { System.out.println(&quot;Date1 时间在 Date2 之后&quot;); } else if (date1.compareTo(date2) &lt; 0) { System.out.println(&quot;Date1 时间在 Date2 之前&quot;); } else if (date1.compareTo(date2) == 0) { System.out.println(&quot;Date1 时间与 Date2 相等&quot;); } else { System.out.println(&quot;程序怎么会运行到这里?正常应该不会&quot;); } } 输出结果： date1 : 2009-12-31 date2 : 2019-01-31 Date1 时间在 Date2 之前 Date.before（），Date.after（）和 Date.equals（） 一种语义上比较友好的方法来比较两个java.util.Date @Test void testDateCompare2() throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date1 = sdf.parse(&quot;2009-12-31&quot;); Date date2 = sdf.parse(&quot;2019-01-31&quot;); System.out.println(&quot;date1 : &quot; + sdf.format(date1)); System.out.println(&quot;date2 : &quot; + sdf.format(date2)); if (date1.after(date2)) { System.out.println(&quot;Date1 时间在 Date2 之后&quot;); } if (date1.before(date2)) { System.out.println(&quot;Date1 时间在 Date2 之前&quot;); } if (date1.equals(date2)) { System.out.println(&quot;Date1 时间与 Date2 相等&quot;); } } 输出结果 date1 : 2009-12-31 date2 : 2019-01-31 Date1 时间在 Date2 之前 Calender.before（），Calender.after（）和 Calender.equals（） 使用java.util.Calendar比较两个 Date 日期 @Test void testDateCompare3() throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date1 = sdf.parse(&quot;2009-12-31&quot;); Date date2 = sdf.parse(&quot;2019-01-31&quot;); System.out.println(&quot;date1 : &quot; + sdf.format(date1)); System.out.println(&quot;date2 : &quot; + sdf.format(date2)); Calendar cal1 = Calendar.getInstance(); Calendar cal2 = Calendar.getInstance(); cal1.setTime(date1); cal2.setTime(date2); if (cal1.after(cal2)) { System.out.println(&quot;Date1 时间在 Date2 之后&quot;); } if (cal1.before(cal2)) { System.out.println(&quot;Date1 时间在 Date2 之前&quot;); } if (cal1.equals(cal2)) { System.out.println(&quot;Date1 时间与 Date2 相等&quot;); } } 输出结果： date1 : 2009-12-31 date2 : 2019-01-31 Date1 时间在 Date2 之前 4. Java 8 日期比较方法 在 Java 8 中，可以使用新的 isBefore（），isAfter（），isEqual（）和 compareTo（）来比较 LocalDate，LocalTime 和 LocalDateTime。以下示例以比较两个java.time.LocalDate @Test void testDateCompare4() throws ParseException { DateTimeFormatter sdf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;); LocalDate date1 = LocalDate.of(2009, 12, 31); LocalDate date2 = LocalDate.of(2019, 1, 31); System.out.println(&quot;date1 : &quot; + sdf.format(date1)); System.out.println(&quot;date2 : &quot; + sdf.format(date2)); System.out.println(&quot;Is...&quot;); if (date1.isAfter(date2)) { System.out.println(&quot;Date1 时间在 Date2 之后&quot;); } if (date1.isBefore(date2)) { System.out.println(&quot;Date1 时间在 Date2 之前&quot;); } if (date1.isEqual(date2)) { System.out.println(&quot;Date1 时间与 Date2 相等&quot;); } } 输出结果 date1 : 2009-12-31 date2 : 2019-01-31 Is... Date1 时间在 Date2 之前 本文地址：https://c.lanmit.com/bianchengkaifa/Java/59964.html ","link":"https://Eakamm.github.io/post/java-chang-yong-shi-jian-bi-jiao-fang-shi/"},{"title":"Sql窗口函数--排名问题","content":"select *, rank() over (order by 成绩 desc) as ranking, dense_rank() over (order by 成绩 desc) as dese_rank, row_number() over (order by 成绩 desc) as row_num from 班级 ","link":"https://Eakamm.github.io/post/sql-chuang-kou-han-shu-pai-ming-wen-ti/"},{"title":"SpringBoot与Quartz整合","content":"Quartz 是一个很牛的任务调度框架，通过它我们可以实现诸如: 定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。记录一下与SpringBoot整合的过程。 ","link":"https://Eakamm.github.io/post/springboot-yu-quartz-zheng-he/"},{"title":"Quartz作业调度","content":"Quartz是一个很牛的任务调度框架，通过它我们可以实现诸如:定时活动、延时活动、订单状态延时检测、服务器状态定时检测等，时间调度任务功能。 一、什么是 Quartz 什么是 Quartz? Quartz 是 OpenSymphony 开源组织在 Job scheduling 领域又一个开源项目，完全由 Java 开发，可以用来执行定时任务，类似于 java.util.Timer。但是相较于 Timer， Quartz 增加了很多功能： 持久性作业 - 就是保持调度定时的状态; 作业管理 - 对调度作业进行有效的管理; 大部分公司都会用到定时任务这个功能。 拿火车票购票来说，当你下单后，后台就会插入一条待支付的 task(job)，一般是 30 分钟，超过 30min 后就会执行这个 job，去判断你是否支付，未支付就会取消此次订单；当你支付完成之后，后台拿到支付回调后就会再插入一条待消费的 task（job），Job 触发日期为火车票上的出发日期，超过这个时间就会执行这个 job，判断是否使用等。 在我们实际的项目中，当 Job 过多的时候，肯定不能人工去操作，这时候就需要一个任务调度框架，帮我们自动去执行这些程序。那么该如何实现这个功能呢？ （1）首先我们需要定义实现一个定时功能的接口，我们可以称之为 Task（或 Job），如定时发送邮件的 task（Job），重启机器的 task（Job），优惠券到期发送短信提醒的 task（Job），实现接口如下： （2）有了任务之后，还需要一个能够实现触发任务去执行的触发器，触发器 Trigger 最基本的功能是指定 Job 的执行时间，执行间隔，运行次数等。 （3）有了 Job 和 Trigger 后，怎么样将两者结合起来呢？即怎样指定 Trigger 去执行指定的 Job 呢？这时需要一个 Schedule，来负责这个功能的实现。 上面三个部分就是 Quartz 的基本组成部分： 调度器：Scheduler 任务：JobDetail 触发器：Trigger，包括 SimpleTrigger 和 CronTrigger 二、Quartz Demo 搭建 下面来利用 Quartz 搭建一个最基本的 Demo。 1、导入依赖的 jar 包： &lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; 2、新建一个能够打印任意内容的 Job： /** * Created by wanggenshen * Date: on 2018/7/7 16:28. * Description: 打印任意内容 */ public class PrintWordsJob implements Job{ @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { String printTime = new SimpleDateFormat(&quot;yy-MM-dd HH-mm-ss&quot;).format(new Date()); System.out.println(&quot;PrintWordsJob start at:&quot; + printTime + &quot;, prints: Hello Job-&quot; + new Random().nextInt(100)); } } 3、创建 Schedule，执行任务： /** * Created by wanggenshen * Date: on 2018/7/7 16:31. * Description: XXX */ public class MyScheduler { public static void main(String\\[\\] args) throws SchedulerException, InterruptedException { // 1、创建调度器Scheduler SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容) JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class) .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build(); // 3、构建Trigger实例,每隔1s执行一次 Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .startNow()//立即生效 .withSchedule(SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(1)//每隔1s执行一次 .repeatForever()).build();//一直执行 //4、执行 scheduler.scheduleJob(jobDetail, trigger); System.out.println(&quot;--------scheduler start ! ------------&quot;); scheduler.start(); //睡眠 TimeUnit.MINUTES.sleep(1); scheduler.shutdown(); System.out.println(&quot;--------scheduler shutdown ! ------------&quot;); } } 运行程序，可以看到程序每隔 1s 会打印出内容，且在一分钟后结束： 三、Quartz 核心详解 下面就程序中出现的几个参数，看一下 Quartz 框架中的几个重要参数： Job 和 JobDetail JobExecutionContext JobDataMap Trigger、SimpleTrigger、CronTrigger （1）Job 和 JobDetail Job 是 Quartz 中的一个接口，接口下只有 execute 方法，在这个方法中编写业务逻辑。 接口中的源码： JobDetail 用来绑定 Job，为 Job 实例提供许多属性： name group jobClass jobDataMap JobDetail 绑定指定的 Job，每次 Scheduler 调度执行一个 Job 的时候，首先会拿到对应的 Job，然后创建该 Job 实例，再去执行 Job 中的 execute() 的内容，任务执行结束后，关联的 Job 对象实例会被释放，且会被 JVM GC 清除。 为什么设计成 JobDetail + Job，不直接使用 Job JobDetail 定义的是任务数据，而真正的执行逻辑是在 Job 中。 这是因为任务是有可能并发执行，如果 Scheduler 直接使用 Job，就会存在对同一个 Job 实例并发访问的问题。而 JobDetail &amp; Job 方式，Sheduler 每次执行，都会根据 JobDetail 创建一个新的 Job 实例，这样就可以规避并发访问的问题。 （2）JobExecutionContext JobExecutionContext 中包含了 Quartz 运行时的环境以及 Job 本身的详细数据信息。 当 Schedule 调度执行一个 Job 的时候，就会将 JobExecutionContext 传递给该 Job 的 execute() 中，Job 就可以通过 JobExecutionContext 对象获取信息。 主要信息有： （3）JobExecutionContext JobDataMap 实现了 JDK 的 Map 接口，可以以 Key-Value 的形式存储数据。 JobDetail、Trigger 都可以使用 JobDataMap 来设置一些参数或信息， Job 执行 execute() 方法的时候，JobExecutionContext 可以获取到 JobExecutionContext 中的信息： 如： JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class) .usingJobData(&quot;jobDetail1&quot;, &quot;这个Job用来测试的&quot;) .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;) .startNow()//立即生效 .withSchedule(SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(1)//每隔1s执行一次 .repeatForever()).build();//一直执行 Job 执行的时候，可以获取到这些参数信息： @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(jobExecutionContext.getJobDetail().getJobDataMap().get(&quot;jobDetail1&quot;)); System.out.println(jobExecutionContext.getTrigger().getJobDataMap().get(&quot;trigger1&quot;)); String printTime = new SimpleDateFormat(&quot;yy-MM-dd HH-mm-ss&quot;).format(new Date()); System.out.println(&quot;PrintWordsJob start at:&quot; + printTime + &quot;, prints: Hello Job-&quot; + new Random().nextInt(100)); } （4）Trigger、SimpleTrigger、CronTrigger Trigger Trigger 是 Quartz 的触发器，会去通知 Scheduler 何时去执行对应 Job。 new Trigger().startAt():表示触发器首次被触发的时间; new Trigger().endAt():表示触发器结束触发的时间; SimpleTrigger SimpleTrigger 可以实现在一个指定时间段内执行一次作业任务或一个时间段内多次执行作业任务。 下面的程序就实现了程序运行 5s 后开始执行 Job，执行 Job 5s 后结束执行： Date startDate = new Date(); startDate.setTime(startDate.getTime() + 5000); Date endDate = new Date(); endDate.setTime(startDate.getTime() + 5000); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;) .startNow()//立即生效 .startAt(startDate) .endAt(endDate) .withSchedule(SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(1)//每隔1s执行一次 .repeatForever()).build();//一直执行 CronTrigger CronTrigger 功能非常强大，是基于日历的作业调度，而 SimpleTrigger 是精准指定间隔，所以相比 SimpleTrigger，CroTrigger 更加常用。CroTrigger 是基于 Cron 表达式的，先了解下 Cron 表达式： 由 7 个子表达式组成字符串的，格式如下： [秒] [分] [小时] [日] [月] [周] [年] Cron 表达式的语法比较复杂， 如：* 30 10 ? * 1/5 * 表示（从后往前看） [指定年份] 的 [ 周一到周五][指定月][不指定日][上午 10 时][30 分][指定秒] 又如：00 00 00 ？ * 10,11,12 1#5 2018 表示 2018 年 10、11、12 月的第一周的星期五这一天的 0 时 0 分 0 秒去执行任务。 下面是给的一个例子： 可通过在线生成 Cron 表达式的工具：http://cron.qqe2.com/ 来生成自己想要的表达式。 下面的代码就实现了每周一到周五上午 10:30 执行定时任务 /** * Created by wanggenshen * Date: on 2018/7/7 20:06. * Description: XXX */ public class MyScheduler2 { public static void main(String\\[\\] args) throws SchedulerException, InterruptedException { // 1、创建调度器Scheduler SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); // 2、创建JobDetail实例，并与PrintWordsJob类绑定(Job执行内容) JobDetail jobDetail = JobBuilder.newJob(PrintWordsJob.class) .usingJobData(&quot;jobDetail1&quot;, &quot;这个Job用来测试的&quot;) .withIdentity(&quot;job1&quot;, &quot;group1&quot;).build(); // 3、构建Trigger实例,每隔1s执行一次 Date startDate = new Date(); startDate.setTime(startDate.getTime() + 5000); Date endDate = new Date(); endDate.setTime(startDate.getTime() + 5000); CronTrigger cronTrigger = TriggerBuilder.newTrigger().withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .usingJobData(&quot;trigger1&quot;, &quot;这是jobDetail1的trigger&quot;) .startNow()//立即生效 .startAt(startDate) .endAt(endDate) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;\\* 30 10 ? \\* 1/5 2018&quot;)) .build(); //4、执行 scheduler.scheduleJob(jobDetail, cronTrigger); System.out.println(&quot;--------scheduler start ! ------------&quot;); scheduler.start(); System.out.println(&quot;--------scheduler shutdown ! ------------&quot;); } } 2018/07/07 20:10 in SH. ","link":"https://Eakamm.github.io/post/quartz-zuo-ye-diao-du/"},{"title":"SpringBoot使用GetMapping时对象作为参数，对象的属性不可以_开头","content":"SpringBoot使用GetMapping时以对象作为参数，对象的属性不可以_开头，在网上也没有找到解释。 ","link":"https://Eakamm.github.io/post/springboot-shi-yong-getmapping-shi-dui-xiang-zuo-wei-can-shu-dui-xiang-de-shu-xing-bu-ke-yi-_-kai-tou/"},{"title":"js中跳出forEach循环","content":"在使用forEach中需要在处理后跳出循环，return和break都无法跳出。经过查找资料后，我找到了两种方法可以实现跳出循环。当然可以使用for循环直接解决🌸🐔 1、使用try···catch捕获异常实现 try{ var array = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;]; array.forEach(function(item,index){ if(item == &quot;third&quot;){ var a = aaaa;// first second 后就报错，就跳出循环了 throw new Error(&quot;ending&quot;);//报错，就跳出循环 }else{ log(item); } }) }catch(e){ if(e.message == &quot;ending&quot;){ log(&quot;结束了&quot;) ; }else{ log(e.message); } } 2、使用arr.some()或者arr.every()替代 some()当内部return true时跳出整个循环。 some() 方法测试是否至少有一个元素通过由提供的函数实现的测试。 var arr = [1,2,3,4,5]; var num = 3; arr.some(function(v){ if(v == num) { // 返回true代表测试通过，结束循环 return true; } console.log(v); }); every()当内部return false时跳出整个循环 every() 方法测试数组的所有元素是否都通过了指定函数的测试。 var arr = [1,2,3,4,5]; var num = 3; arr.every(function(v){ if(v == num) { return false; }else{ console.log(v); return true; } }); ","link":"https://Eakamm.github.io/post/js-zhong-tiao-chu-foreach-xun-huan/"},{"title":"Pandas基础（一）","content":"Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。 1、Servies pandas创建一个一维数组 import pandas as pd import numpy as np s = pd.Series(['a', 'b', 'c'], index=[1, 2, 3]) # 获取索引序列 print(s.index) # 根据索引查找数据 print(s[1]) s[1] = &quot;e&quot; print(s[1]) print('----------------------------------') # 多个索引或值查找 s2 = pd.Series([1, 2, 6], index=['a', 'b', 'c']) # 自定义的索引('a', 'b', 'c') print(s2[['a', 'b']]) # 第n行(0,1,2) print(s2[[1, 2]]) # 值小于等于n print(s2[s2 &lt;= 3]) print('----------------------------------') # in判断索引是否存在 print(1 in s) 通过.index改变索引 # Series的索引可以通过按位置赋值的方式进行改变 s.index = ['a','b','c'] Python切片中是不包含尾部的，Series的自定义字符串索引的切片与之不同. import pandas as pd import numpy as np # 字符串索引 s = pd.Series([1,2,3], index=['a', 'b', 'c']) # 数字索引 s1 = pd.Series([1,2,3], index=[1, 2, 3]) s2 = [1,2,3] print(s2[0:1]) # 根据行数做切片与普通数组的切片相同 print(s1[1:2]) # 自定义字符串索引包含尾部 print(s['a':'b']) # 可以使用切片更改数据 s['a':'b'] = 4 print(s) 2、DataFrame 2.1、创建 最常用的方式是利用包含等长度列表或NumPy数组的字典来形成DataFrame(某一列没有赋值，会出现缺省值NaN) import pandas as pd data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002, 2003], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]} frame = pd.DataFrame(data) print(frame) 设置列名与行名，debt列为空，为NaN &gt;&gt;&gt; frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'], ... index=['one', 'two', 'three', 'four', ... 'five', 'six']) &gt;&gt;&gt; frame2 one 2000 Ohio 1.5 NaN two 2001 Ohio 1.7 NaN three 2002 Ohio 3.6 NaN four 2001 Nevada 2.4 NaN five 2002 Nevada 2.9 NaN six 2003 Nevada 3.2 NaN 2.2、查找 loc[]获取某一行的数据 import pandas as pd data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'], 'year': [2000, 2001, 2002, 2001, 2002, 2003], 'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]} frame = pd.DataFrame(data) # 查找某一行 print(frame) print(frame.loc[1]) # 多个索引查找 # 创建新的一列 frame['test'] = frame.state == 'Ohio' print(frame) # 删除一列 del frame['test'] print(frame.columns) 2.3、根据布尔值切片 可以根据一个布尔值数组选择数据，也可以比较所有的元素，对符合要求的元素执行操作。 import pandas as pd import numpy as np frame = pd.DataFrame(np.arange(20).reshape(4, 5), index=list('abcd'), columns=list('abcde')) # frame &lt; 5 print(frame &lt; 5) # 将小于5的元素改为0 frame[frame &lt; 5] = 0 print(frame) # 根据列的比较结果显示数据 print(frame[frame['b'] &gt; 10]) print(frame) 2.4、loc与iloc索引 标签选出单行多列的数据可以使用loc（也就是自定义的索引） import numpy as np import pandas as pd frame = pd.DataFrame(np.arange(20).reshape(4, 5), index=list('abcd'), columns=list('abcde')) # 获取某一行 print(frame.loc['a']) # 获取某一行的n列数据 print(frame.loc['a',['a', 'b']]) # print(frame.loc[['a','b'],['a', 'b']]) 整数标签iloc进行类似的数据选择 import numpy as np import pandas as pd frame = pd.DataFrame(np.arange(20).reshape(4, 5), index=list('abcd'), columns=list('abcde')) print(frame.iloc[1]) print(frame.iloc[1,[1,2]]) print(frame.iloc[[1,2],[1,2]]) 2.5、整数索引问题 import numpy as np import pandas as pd 当使用字符串的索引就不会对s[-1]产生歧义 所以你有一个包含整数的轴索引，数据选择时请始终使用标签索引。 2.6、广播机制 2.7、函数 使用apply可以取出每一行或每一列的元素。axis = 'columns'取出每一行，以行为索引。默认为列。 可以使用函数对数据进行更复杂的操作 import numpy as np import pandas as pd df = pd.DataFrame(np.arange(20).reshape(4, 5), columns=list('abcde')) # 求每组数据的最大最小值的差 def f(x): return x.max()-x.min() # 默认为取出每列 series = df.apply(f) print(series) # 取出每行 series = df.apply(f, axis=&quot;columns&quot;) print(series) 使用applymap取出每个元素 import numpy as np import pandas as pd df = pd.DataFrame(np.arange(20).reshape(4, 5), columns=list('abcde')) # 处理所有的元素 # 求平方 def f2(x): return x**2 data_frame = df.applymap(f2) print(data_frame) # 处理某一行 data_frame = df.loc[1].map(f2) print(data_frame) ","link":"https://Eakamm.github.io/post/pandas-ji-chu-yi/"},{"title":"常用数字正则表达式","content":"验证数字的正则表达式集 类型 正则表达式 部分验证的格式 验证数字 [1]*$ 验证n位的数字 ^\\d{n}$ 验证至少n位数字 ^\\d{n,}$ 验证m-n位的数字 ^\\d{m,n}$ 验证零和非零开头的数字 ^(0 [1-9][0-9]*)$ 验证有两位小数的正实数 [2]+(.[0-9]{2})?$ 验证有1-3位小数的正实数 [3]+(.[0-9]{1,3})?$ 验证非零的正整数 ^+?[1-9][0-9]*$ 验证非零的负整数 ^-[1-9][0-9]*$ 验证非负整数（正整数 + 0） ^\\d+$ 验证非正整数（负整数 + 0） ^((-\\d+) (0+))$ 验证长度为3的字符 ^.{3}$ 验证由26个英文字母组成的字符串 [4]+$ 验证由26个大写英文字母组成的字符串 [5]+$ 验证由26个小写英文字母组成的字符串 [6]+$ 验证由数字和26个英文字母组成的字符串 [7]+$ 验证由数字、26个英文字母或者下划线组成的字符串 ^\\w+$ 验证用户密码 [8]\\w{5,17}$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。 验证是否含有 ^%&amp;',;=?$&quot; 等字符 [^%&amp;',;=?$\\x22]+ 验证汉字 [9],{0,}$ 验证Email地址 /^([a-zA-Z0-9]+[_ _ 验证InternetURL ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=])?$ ；[10]+://(w+(-w+))(.(w+(-w+)))(?S*)?$ 验证电话号码 ^(\\d3,4\\d3,4 \\d{3,4}-)?\\d{7,8}$ 验证身份证号（15位或18位数字） ^\\d{15} \\d{}18$ 验证一年的12个月 ^(0?[1-9] 1[0-2])$ 验证一个月的31天 ^((0?[1-9]) ((1 整数 ^-?\\d+$ 非负浮点数（正浮点数 + 0） ^\\d+(.\\d+)?$ 正浮点数 ^(([0-9]+.[0-9][1-9][0-9]) ([0-9][1-9][0-9].[0-9]+) 非正浮点数 （负浮点数 + 0） ^((-\\d+(.\\d+)?) (0+(.0+)?))$ 负浮点数 ^(-(([0-9]+.[0-9][1-9][0-9]) ([0-9][1-9][0-9].[0-9]+) 浮点数 ^(-?\\d+)(.\\d+)?$ 0-9 ↩︎ 0-9 ↩︎ 0-9 ↩︎ A-Za-z ↩︎ A-Z ↩︎ a-z ↩︎ A-Za-z0-9 ↩︎ a-zA-Z ↩︎ \\u4e00-\\u9fa5 ↩︎ a-zA-z ↩︎ ","link":"https://Eakamm.github.io/post/chang-yong-shu-zi-zheng-ze-biao-da-shi/"},{"title":"JWT","content":" Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519). 该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。 原文地址 [www.jianshu.com](https://www.jianshu.com/p/576dbf44b2ae) 起源 说起 JWT，我们应该来谈一谈基于 token 的认证和传统的 session 认证的区别。 传统的 session 认证 我们知道，http 协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据 http 协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为 cookie, 以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了, 这就是传统的基于 session 认证。 但是这种基于 session 的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于 session 认证应用的问题就会暴露出来. 基于 session 认证所显露的问题 Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言 session 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上, 这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。 CSRF: 因为是基于 cookie 来进行用户识别的, cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。 基于 token 的鉴权机制 基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。 流程上是这样的： 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个 token 客户端存储 token，并在每次请求时附送上这个 token 值 服务端验证 token 值，并返回数据 这个 token 必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。 那么我们现在回到 JWT 的主题上。 JWT 长什么样？ JWT 是由三段信息构成的，将这三段信息文本用.链接一起就构成了 Jwt 字符串。就像这样: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ JWT 的构成 第一部分我们称它为头部（header), 第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature). header jwt 的头部承载两部分信息： 声明类型，这里是 jwt 声明加密的算法 通常直接使用 HMAC SHA256 完整的头部就像下面这样的 JSON： { 'typ': 'JWT', 'alg': 'HS256' } 然后将头部进行 base64 加密（该加密是可以对称解密的), 构成了第一部分. eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 playload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ： iss: jwt 签发者 sub: jwt 所面向的用户 aud: 接收 jwt 的一方 exp: jwt 的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该 jwt 都是不可用的. iat: jwt 的签发时间 jti: jwt 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息. 但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个 payload: { &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true } 然后将其进行 base64 加密，得到 Jwt 的第二部分。 eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signature jwt 的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64 后的) payload (base64 后的) secret 这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用.连接组成的字符串，然后通过 header 中声明的加密方式进行加盐secret组合加密，然后就构成了 jwt 的第三部分。 // javascript var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload); var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 将这三部分用.连接成一个完整的字符串, 构成了最终的 jwt: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 注意：secret 是保存在服务器端的，jwt 的签发生成也是在服务器端的，secret 就是用来进行 jwt 的签发和 jwt 的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个 secret, 那就意味着客户端是可以自我签发 jwt 了。 如何应用 一般是在请求头里加入Authorization，并加上Bearer标注： fetch('api/user/1', { headers: { 'Authorization': 'Bearer ' + token } }) 服务端会验证 token，如果验证通过就会返回相应的资源。整个流程就是这样的: jwt-diagram 总结 优点 因为 json 的通用性，所以 JWT 是可以进行跨语言支持的，像 JAVA,JavaScript,NodeJS,PHP 等很多语言都可以使用。 因为有了 payload 部分，所以 JWT 可以在自身存储一些其他业务逻辑所必要的非敏感信息。 便于传输，jwt 的构成非常简单，字节占用很小，所以它是非常便于传输的。 它不需要在服务端保存会话信息, 所以它易于应用的扩展 安全相关 不应该在 jwt 的 payload 部分存放敏感信息，因为该部分是客户端可解密的部分。 保护好 secret 私钥，该私钥非常重要。 如果可以，请使用 https 协议 微服务架构介绍 1.1 什么是微服务架构？ 形像一点来说，微服务架构就像搭积木，每个微服务都是一个零件，并使... Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智... 注：参考 Spring Security 整合 JSON Web Token(JWT) 提升 REST 安全性，写的... ","link":"https://Eakamm.github.io/post/jwt/"},{"title":"Springboot测试","content":"1、注解 @SpringBootTest替代了spring-test中的@ContextConfiguration注解，目的是加载ApplicationContext，启动spring容器。 2、Junit5 1、基本注解 基本注解 JUnit5的注解与JUnit4的注解有所变化，以下列出的注解为部分我觉得常用的注解 @Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 @ParameterizedTest :表示方法是参数化测试，下方会有详细介绍 @RepeatedTest :表示方法可重复执行，下方会有详细介绍 @DisplayName :为测试类或者测试方法设置展示名称 @BeforeEach :表示在每个单元测试之前执行 @AfterEach :表示在每个单元测试之后执行 @BeforeAll :表示在所有单元测试之前执行 @AfterAll :表示在所有单元测试之后执行 @Tag :表示单元测试类别，类似于JUnit4中的@Categories @Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore @Timeout :表示测试方法运行如果超过了指定时间将会返回错误 @ExtendWith :为测试类或测试方法提供扩展类引用 2、更强大的断言 JUnit5使用了新的断言类:org.junit.jupiter.api.Assertions。相比之前的Assert断言类多了许多新的功能，并且大量方法支持Java8的Lambda表达式。 以下为两个与JUnit4不太一样的断言方式: 1. 异常断言 在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows() ,配合函数式编程就可以进行使用。 @Test @DisplayName(&quot;异常测试&quot;) public void exceptionTest() { ArithmeticException exception = Assertions.assertThrows( //扔出断言异常 ArithmeticException.class, () -&gt; System.out.println(1 % 0)); } 2.超时断言 Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间 @Test @DisplayName(&quot;超时测试&quot;) public void timeoutTest() { //如果测试方法时间超过1s将会异常 Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500)); } ","link":"https://Eakamm.github.io/post/springboot-ce-shi/"},{"title":"傻瓜函数式编程（转载）","content":"译者：justinyhuang 这篇文章是原文《Functional Programming For The Rest of Us》的中文翻译。 因为懒，在知道有这篇文章的时候我Google了若干篇中文翻译版，打算在吃午饭的时候随便扫扫了解一下。可是偏偏运气不太好，搜到的几篇翻译质量都不太理想： 这篇文章是原文《Functional Programming For The Rest of Us》的中文翻译。 因为懒，在知道有这篇文章的时候我Google了若干篇中文翻译版，打算在吃午饭的时候随便扫扫了解一下。可是偏偏运气不太好，搜到的几篇翻译质量都不太理想：有把“Is it edible”被翻译成“它可以被掌握吗”的，有把“calculus”翻译成“微积分”的，几乎所有的版本都把“With any luck your coworkers will start making fun of you for your FP comments in no time” 译为“很快你的同事就会开始取笑你对函数式编程的观点了”……读起来矛盾拗口让人担心会不会有其他地方出错引起误解，让人不敢再往下看。 看来还是“自己动手，丰衣足食”，我最终还是开始自己翻译这篇文章。 这个版本在追求“信达雅”的同时，希望在不改变原意的前提下用中文语气/语境来进行本土化表达。唯一的例外是专业术语，如continuation，关于术语的翻译有很多讨论，我倾向于不翻译直接用，这样对以后写程序以及和国际友人交流都有帮助。 如果您在阅读之后没有明显感到央视翻译腔的话，我的目的就算达到了。非常期待您的任何反馈。 对了，在翻译的同时，我还把这篇文章转成Markdown的格式以图更好的保存和传播。You are welcome Slava 😉 译者 于 2013年 2006 年 6 月 19 日，星期一 开篇 我们这些码农做事都是很拖拉的。每天例行报到后，先来点咖啡，看看邮件还有 RSS 订阅的文章。然后翻翻新闻还有那些技术网站上的更新，再过一遍编程论坛口水区里那些无聊的论战。最后从头把这些再看一次以免错过什么精彩的内容。然后就可以吃午饭了。饭饱过后，回来盯着 IDE 发一会呆，再看看邮箱，再去搞杯咖啡。光阴似箭，可以回家了…… （在被众人鄙视之前）我唯一想说的是，在这些拖拉的日子里总会时不时读到一些不明觉厉的文章。如果没有打开不应该打开的网站，每隔几天你都可以看到至少一篇这样的东西。它们的共性：难懂，耗时，于是这些文章就慢慢的堆积成山了。很快你就会发现自己已经累积了一堆的收藏链接还有数不清的 PDF 文件，此时你只希望隐入一个杳无人烟的深山老林里什么也不做，用一年半载好好的消化这些私藏宝贝。当然，我是说最好每天还是能有人来给送吃的顺带帮忙打扫卫生倒垃圾，哇哈哈。 我不知道你都收藏了些什么，我的阅读清单里面相当大部分都是函数式编程相关的东东：基本上是最难啃的。这些文章充斥着无比枯燥的教科书语言，我想就连那些在华尔街浸淫 10 年以上的大牛都无法搞懂这些函数式编程（简称 FP）文章到底在说什么。你可以去花旗集团或者德意志银行找个项目经理来问问1：你们为什么要选 JMS 而不用 Erlang？答案基本上是：我认为这个学术用的语言还无法胜任实际应用。可是，现有的一些系统不仅非常复杂还需要满足十分严苛的需求，它们就都是用函数式编程的方法来实现的。这，就说不过去了。 关于 FP 的文章确实比较难懂，但我不认为一定要搞得那么晦涩。有一些历史原因造成了这种知识断层，可是 FP 概念本身并不难理解。我希望这篇文章可以成为一个“FP 入门指南”，帮助你从指令式编程走向函数式编程。先来点咖啡，然后继续读下去。很快你对 FP 的理解就会让同事们刮目相看了。 什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？倘若它真的像那些鼓吹 FP 的人说的那么好，为什么实际应用中那么少见？为什么只有那些在读博士的家伙想要用它？而最重要的是，它母亲的怎么就那么难学？那些所谓的 closure、continuation，currying，lazy evaluation 还有 no side effects 都是什么东东（译者：本着保留专用术语的原则，此处及下文类似情形均不译）？如果没有那些大学教授的帮忙怎样把它应用到实际工程里去？为什么它和我们熟悉的万能而神圣的指令式编程那么的不一样？ 我们很快就会解开这些谜团。刚才我说过实际工程和学术界之间的知识断层是有其历史原因的，那么就先让我来解释一下这个问题。答案，就在接下来的一次公园漫步中： 公园漫步 时间机器启动……我们来到公元前 380 年，也就是 2000 多年前的雅典城外。这是一个阳光明媚的久违的春天，柏拉图和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。 “你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。 小男仆望向水池旁边的两个男生，“他们差不多一样高。”。 “‘差不多一样高’是什么意思？”柏拉图问。 “嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。” 柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？” 思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。” 说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解‘完全相等’这个概念？” 小男仆看起来很困惑。“这我就不知道了。” 这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。 如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？2 数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。 如果半人马阿尔法上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子（译者：偶的妈你咋知道？）也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏（译者：那狗可以么？）可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。 有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。 历史回眸3 再次启动时间机……这次到达的是 20 世纪 30 年代，离今天近了很多。无论新旧大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。 新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫阿隆佐·邱奇(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有艾伦·图灵、约翰·冯·诺伊曼、库尔特·哥德尔。 这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？ 在与这些人的合作下，阿隆佐设计了一个名为lambda 演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母 lambda（λ），这种系统因此得名4。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。 除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和 lambda 演算的能力是一样的。 如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM 制造的 Mark 一号就是用来计算这些发射数据表的第一台机器。Mark 一号重 5 吨，由 75 万个零部件构成，每一秒可以完成 3 次运算。 战后，人们为提高计算能力而做出的努力并没有停止。1949 年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。 到了 50 年代末，一个叫 John McCarthy 的 MIT 教授（他也是普林斯顿的硕士）对阿隆佐的成果产生了兴趣。1958 年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐 lambda 演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了 Lisp 强大的能力。1973 年在 MIT 人工智能实验室的一些程序员研发出一种机器，并把它叫做 Lisp 机。于是阿隆佐的 lambda 演算也有自己的硬件实现了！ 函数式编程 函数式编程是阿隆佐思想在现实世界中的实现。不过不是全部的 lambda 演算思想都可以运用到实际中，因 lambda 演算在设计的时候就不是为了在各种现实世界中的限制下工作的。所以，就像面向对象的编程思想一样，函数式编程只是一系列想法，而不是一套严苛的规定。有很多支持函数式编程的程序语言，它们之间的具体设计都不完全一样。在这里我将用 Java 写的例子介绍那些被广泛应用的函数式编程思想（没错，如果你是受虐狂你可以用 Java 写出函数式程序）。在下面的章节中我会在 Java 语言的基础上，做一些修改让它变成实际可用的函数式编程语言。那么现在就开始吧。 Lambda 演算在最初设计的时候就是为了研究计算相关的问题。所以函数式编程主要解决的也是计算问题，而出乎意料的是，是用函数来解决的！（译者：请理解原作者的苦心，我想他是希望加入一点调皮的风格以免读者在中途睡着或是转台……）。函数就是函数式编程中的基础元素，可以完成几乎所有的操作，哪怕最简单的计算，也是用函数完成的。我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式（这样我们就不用把所有的代码都写在同一行里了）。所以我们这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。在 Java 中就意味着每一个变量都将被声明为 final（如果你用 C++，就是 const）。在 FP 中，没有非 final 的变量。 final int i = 5; final int j = i + 3; 既然 FP 中所有的变量都是 final 的，可以引出两个规定：一是变量前面就没有必要再加上 final 这个关键字了，二是变量就不能再叫做‘变量’了……于是现在开始对 Java 做两个改动：所有 Java 中声明的变量默认为 final，而且我们把所谓的‘变量’称为‘符号’。 到现在可能会有人有疑问：这个新创造出来的语言可以用来写什么有用的复杂一些的程序吗？毕竟，如果每个符号的值都是不能修改的，那么我们就什么东西都不能改变了！别紧张，这样的说法不完全正确。阿隆佐在设计 lambda 演算的时候他并不想要保留状态的值以便稍后修改这些值。他更关心的是基于数据之上的操作（也就是更容易理解的“计算”）。而且，lambda 演算和图灵机已经被证明了是具有同样能力的系统，因此指令式编程能做到的函数式编程也同样可以做到。那么，怎样才能做到呢？ 事实上函数式程序是可以保存状态的，只不过它们用的不是变量，而是函数。状态保存在函数的参数中，也就是说在栈上。如果你需要保存一个状态一段时间并且时不时的修改它，那么你可以编写一个递归函数。举个例子，试着写一个函数，用来反转一个 Java 的字符串。记住咯，这个程序里的变量都是默认为 final 的5。 String reverse(String arg) { if(arg.length == 0) { return arg; } else { return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1); } } 这个方程运行起来会相对慢一些，因为它重复调用自己6。同时它也会大量的消耗内存，因为它会不断的分配创建内存对象。无论如何，它是用函数式编程思想写出来的。这时候可能有人要问了，为什么要用这种奇怪的方式编写程序呢？嘿，我正准备告诉你。 FP 之优点 你大概已经在想：上面这种怪胎函数怎么也不合理嘛。在我刚开始学习 FP 的时候我也这样想的。不过后来我知道我是错的。使用这种方式编程有很多好处。其中一些是主观的。比如说有人认为函数式程序更容易理解。这个我就不说了，哪怕街上随便找个小孩都知道‘容易理解’是多么主观的事情。幸运的是，客观方面的好处还有很多。 单元测试 因为 FP 中的每个符号都是 final 的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它作用域之外的值给其他函数继续使用（在指令式编程中可以用类成员或是全局变量做到）。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。 这正是单元测试工程师梦寐以求的啊。现在测试程序中的函数时只需要关注它的参数就可以了。完全不需要担心函数调用的顺序，也不用费心设置外部某些状态值。唯一需要做的就是传递一些可以代表边界条件的参数给这些函数。相对于指令式编程，如果 FP 程序中的每一个函数都能通过单元测试，那么我们对这个软件的质量必将信心百倍。反观 Java 或者 C++，仅仅检查函数的返回值是不够的：代码可能修改外部状态值，因此我们还需要验证这些外部的状态值的正确性。在 FP 语言中呢，就完全不需要。 调试查错 如果一段 FP 程序没有按照预期设计那样运行，调试的工作几乎不费吹灰之力。这些错误是百分之一百可以重现的，因为 FP 程序中的错误不依赖于之前运行过的不相关的代码。而在一个指令式程序中，一个 bug 可能有时能重现而有些时候又不能。因为这些函数的运行依赖于某些外部状态， 而这些外部状态又需要由某些与这个 bug 完全不相关的代码通过某个特别的执行流程才能修改。在 FP 中这种情况完全不存在：如果一个函数的返回值出错了，它一直都会出错，无论你之前运行了什么代码。 一旦问题可以重现，解决它就变得非常简单，几乎就是一段愉悦的旅程。中断程序的运行，检查一下栈，就可以看到每一个函数调用时使用的每一个参数，这一点和指令式代码一样。不同的是指令式程序中这些数据还不足够，因为函数的运行还可能依赖于成员变量，全局变量，还有其他类的状态（而这些状态又依赖于类似的变量）。FP 中的函数只依赖于传给它的参数，而这些参数就在眼前！还有，对指令式程序中函数返回值的检查并不能保证这个函数是正确运行的。还要逐一检查若干作用域以外的对象以确保这个函数没有对这些牵连的对象做出什么越轨的行为（译者：好吧，翻译到这里我自己已经有点激动了）。对于一个 FP 程序，你要做的仅仅是看一下函数的返回值。 把栈上的数据过一遍就可以得知有哪些参数传给了什么函数，这些函数又返回了什么值。当一个返回值看起来不对头的那一刻，跳进这个函数看看里面发生了什么。一直重复跟进下去就可以找到 bug 的源头！ 并发执行 不需要任何改动，所有 FP 程序都是可以并发执行的。由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。在 FP 程序中没有哪个线程可以修改任何数据，更不用说多线程之间了。这使得我们可以轻松的添加线程，至于那些祸害并发程序的老问题，想都不用想！ 既然是这样，为什么没有人在那些高度并行的那些应用程序中采用 FP 编程呢？事实上，这样的例子并不少见。爱立信开发了一种 FP 语言，名叫 Erlang，并应用在他们的电信交换机上，而这些交换机不仅容错度高而且拓展性强。许多人看到了 Erlang 的这些优势也纷纷开始使用这一语言。在这里提到的电信交换控制系统远远要比华尔街上使用的系统具有更好的扩展性也更可靠。事实上，用 Erlang 搭建的系统并不具备可扩展性和可靠性，而 Java 可以提供这些特性。Erlang 只是像岩石一样结实不容易出错而已。 FP 关于并行的优势不仅于此。就算某个 FP 程序本身只是单线程的，编译器也可以将其优化成可以在多 CPU 上运行的并发程序。以下面的程序为例： String s1 = somewhatLongOperation1(); String s2 = somewhatLongOperation2(); String s3 = concatenate(s1, s2); 如果是函数式程序，编译器就可以对代码进行分析，然后可能分析出生成字符串 s1 和 s2 的两个函数可能会比较耗时，进而安排它们并行运行。这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。在函数式编程中，自动分析代码并找到适合并行执行的函数十分简单，和分析 C 的内联函数没什么两样。从这个角度来说用 FP 风格编写的程序是“永不过时”的（虽然我一般不喜欢说大话空话，不过这次就算个例外吧）。硬件厂商已经没办法让 CPU 运行得再快了。他们只能靠增加 CPU 核的数量然后用并行来提高运算的速度。这些厂商故意忽略一个事实：只有可以并行的软件才能让你花大价钱买来的这些硬件物有所值。指令式的软件中只有很小一部分能做到跨核运行，而所有的函数式软件都能实现这一目标，因为 FP 的程序从一开始就是可以并行运行的。 热部署 在 Windows 早期，如果要更新系统那可是要重启电脑的，而且还要重启很多次。哪怕只是安装一个新版本的播放器。到了 XP 的时代这种情况得到比较大的改善，尽管还是不理想（我工作的时候用的就是 Windows，就在现在，我的系统托盘上就有个讨厌的图标，我不重启机子就不消失）。这一方面 Unix 好一些，曾经。只需要暂停一些相关的部件而不是整个操作系统，就可以安装更新了。虽然是要好一些了，对很多服务器应用来说这也还是不能接受的。电信系统要求的是 100%的在线率，如果一个救急电话因为系统升级而无法拨通，成千上万的人就会因此丧命。同样的，华尔街的那些公司怎么也不能说要安装软件而在整个周末停止他们系统的服务。 最理想的情况是更新相关的代码而不用暂停系统的其他部件。对指令性程序来说是不可能的。想想看，试着在系统运行时卸载掉一个 Java 的类然后再载入这个类的新的实现，这样做的话系统中所有该类的实例都会立刻不能运行，因为该类的相关状态已经丢失了。这种情况下可能需绞尽脑汁设计复杂的版本控制代码，需要将所有这种类正在运行的实例序列化，逐一销毁它们，然后创建新类的实例，将现有数据也序列化后装载到这些新的实例中，最后希望负责装载的程序可以正确的把这些数据移植到新实例中并正常的工作。这种事很麻烦，每次有新的改动都需要手工编写装载程序来完成更新，而且这些装载程序还要很小心，以免破坏了现有对象之间的联系。理论上是没问题，可是实际上完全行不通。 FP 的程序中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个 diff，然后用这个 diff 更新现有的代码，新代码的热部署就完成了。其它的事情有 FP 的语言工具自动完成！如果还有人认为这只存在于科幻小说中，他需要再想想：多年来 Erlang 工程师已经使用这种技术对它们的系统进行升级而完全不用暂停运行了。 机器辅助证明及优化 FP 语言有一个特性很有意思，那就是它们是可以用数学方法来分析的。FP 语言本身就是形式系统的实现，只要是能在纸上写出来的数学运算就可以用这种语言表述出来。于是只要能够用数学方法证明两段代码是一致的，编译器就可以把某段代码解析成在数学上等同的但效率又更高的另外一段代码7。 关系数据库已经用这种方法进行优化很多年了。没有理由在常规的软件行业就不能应用这种技术。 另外，还可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来！对于那些对缺陷零容忍的系统来说，这一功能简直就是无价之宝。例如心脏起搏器，例如飞行管控系统，这几乎就是必须满足的需求。哪怕你正在开发的程序不是为了完成什么重要核心任务，这些工具也可以帮助你写出更健壮的程序，直接甩竞争对手 n 条大街。 高阶函数 我还记得在了解到 FP 以上的各种好处后想到：“这些优势都很吸引人，可是，如果必须非要用这种所有变量都是 final 的蹩脚语言，估计还是不怎么实用吧”。其实这样的想法是不对的。对于 Java 这样的指令式语言来说，如果所有的变量都是必须是 final 的，那么确实很束手束脚。然而对函数式语言来说，情况就不一样了。函数式语言提供了一种特别的抽象工具，这种工具将帮助使用者编写 FP 代码，让他们甚至都没想到要修改变量的值。高阶函数就是这种工具之一。 FP 语言中的函数有别于 Java 或是 C。可以说这种函数是一个全集：Java 函数可以做到的它都能做，同时它还有更多的能力。首先，像在 C 里写程序那样创建一个函数： int add(int i, int j) { return i + j; } 看起来和 C 程序没什么区别，但是很快你就可以看出区别来。接下来我们扩展 Java 的编译器以便支持这种代码，也就是说，当我们写下以上的程序编译器会把它转化成下面的 Java 程序（别忘了，所有的变量都是 final 的）： class add_function_t { int add(int i, int j) { return i + j; } } add_function_t add = new add_function_t(); 在这里，符号 add 并不是一个函数，它是只有一个函数作为其成员的简单的类。这样做有很多好处，可以在程序中把 add 当成参数传给其他的函数，也可以把 add 赋给另外一个符号，还可以在运行时创建 add_function_t 的实例然后在不再需要这些实例的时候由系统回收机制处理掉。这样做使得函数成为和 integer 或是 string 这样的第一类对象。对其他函数进行操作（比如说把这些函数当成参数）的函数，就是所谓的高阶函数。别让这个看似高深的名字吓倒你（译者：好死不死起个这个名字，初一看还准备搬出已经尘封的高数教材……），它和 Java 中操作其他类（也就是把一个类实例传给另外的类）的类没有什么区别。可以称这样的类为“高阶类”，但是没人会在意，因为 Java 圈里就没有什么很强的学术社团。（译者：这是高级黑吗？） 那么什么时候该用高阶函数，又怎样用呢？我很高兴有人问这个问题。设想一下，你写了一大堆程序而不考虑什么类结构设计，然后发现有一部分代码重复了几次，于是你就会把这部分代码独立出来作为一个函数以便多次调用（所幸学校里至少会教这个）。如果你发现这个函数里有一部分逻辑需要在不同的情况下实现不同的行为，那么你可以把这部分逻辑独立出来作为一个高阶函数。搞晕了？下面来看看我工作中的一个真实的例子。 假设有一段 Java 的客户端程序用来接收消息，用各种方式对消息做转换，然后发给一个服务器。 class MessageHandler { void handleMessage(Message msg) { // ... msg.setClientCode(&quot;ABCD_123&quot;); // ... sendMessage(msg); } // ... } 再进一步假设，整个系统改变了，现在需要发给两个服务器而不再是一个了。系统其他部分都不变，唯独客户端的代码需要改变：额外的那个服务器需要用另外一种格式发送消息。应该如何处理这种情况呢？我们可以先检查一下消息要发送到哪里，然后选择相应的格式把这个消息发出去： class MessageHandler { void handleMessage(Message msg) { // ... if(msg.getDestination().equals(&quot;server1&quot;) { msg.setClientCode(&quot;ABCD_123&quot;); } else { msg.setClientCode(&quot;123_ABC&quot;); } // ... sendMessage(msg); } // ... } 可是这样的实现是不具备扩展性的。如果将来需要增加更多的服务器，上面函数的大小将呈线性增长，使得维护这个函数最终变成一场噩梦。面向对象的编程方法告诉我们，可以把 MessageHandler 变成一个基类，然后将针对不同格式的消息编写相应的子类。 abstract class MessageHandler { void handleMessage(Message msg) { // ... msg.setClientCode(getClientCode()); // ... sendMessage(msg); } abstract String getClientCode(); // ... } class MessageHandlerOne extends MessageHandler { String getClientCode() { return &quot;ABCD_123&quot;; } } class MessageHandlerTwo extends MessageHandler { String getClientCode() { return &quot;123_ABCD&quot;; } } 这样一来就可以为每一个接收消息的服务器生成一个相应的类对象，添加服务器就变得更加容易维护了。可是，这一个简单的改动引出了很多的代码。仅仅是为了支持不同的客户端行为代码，就要定义两种新的类型！现在来试试用我们刚才改造的语言来做同样的事情，注意，这种语言支持高阶函数： class MessageHandler { void handleMessage(Message msg, Function getClientCode) { // ... Message msg1 = msg.setClientCode(getClientCode()); // ... sendMessage(msg1); } // ... } String getClientCodeOne() { return &quot;ABCD_123&quot;; } String getClientCodeTwo() { return &quot;123_ABCD&quot;; } MessageHandler handler = new MessageHandler(); handler.handleMessage(someMsg, getClientCodeOne); 在上面的程序里，我们没有创建任何新的类型或是多层类的结构。仅仅是把相应的函数作为参数进行传递，就做到了和用面向对象编程一样的事情，而且还有额外的好处：一是不再受限于多层类的结构。这样做可以做运行时传递新的函数，可以在任何时候改变这些函数，而且这些改变不仅更加精准而且触碰的代码更少。这种情况下编译器其实就是在替我们编写面向对象的“粘合”代码（译者：又称胶水代码，粘接代码）！除此之外我们还可以享用 FP 编程的其他所有优势。函数式编程能提供的抽象服务还远不止于此。高阶函数只不过是个开始。 Currying 我遇见的大多数码农都读过“四人帮”的那本《设计模式》。任何稍有自尊心的码农都会说这本书和语言无关，因此无论你用什么编程语言，当中提到的那些模式大体上适用于所有软件工程。听起来很厉害，然而事实却不是这样。 函数式语言的表达能力很强。用这种语言编程的时候基本不需要设计模式，因为这种语言层次已经足够高，使得使用者可以以概念编程，从而完全不需要设计模式了。以适配器模式为例（有人知道这个模式和外观模式有什么区别吗？怎么觉得有人为了出版合同的要求而硬生生凑页数？）（译者：您不愧是高级黑啊）。对于一个支持 currying 技术的语言来说，这个模式就是多余的。 在 Java 中最有名的适配器模式就是在其“默认”抽象单元中的应用：类。在函数式语言中这种模式其实就是函数。在这个模式中，一个接口被转换成另外一个接口，让不同的用户代码调用。接下来就有一个适配器模式的例子： int pow(int i, int j); int square(int i) { return pow(i, 2); } 上面的代码中 square 函数计算一个整数的平方，这个函数的接口被转换成计算一个整数的任意整数次幂。在学术圈里这种简单的技术就被叫做 currying（因为逻辑学家哈斯凯尔·加里用其数学技巧将这种技术描述出来，于是就以他的名字来命名了）。在一个 FP 语言中函数（而不是类）被作为参数进行传递，currying 常常用于转化一个函数的接口以便于其他代码调用。函数的接口就是它的参数，于是 currying 通常用于减少函数参数的数量（见前例）。 函数式语言生来就支持这一技术，于是没有必要为某个函数手工创建另外一个函数去包装并转换它的接口，这些函数式语言已经为你做好了。我们继续拓展 Java 来支持这一功能。 square = int pow(int i, 2); 上面的语句实现了一个平方计算函数，它只需要一个参数。它会继而调用 pow 函数并且把第二个参数置为 2。编译过后将生成以下 Java 代码： class square_function_t { int square(int i) { return pow(i, 2); } } square_function_t square = new square_function_t(); 从上面的例子可以看到，很简单的，函数 pow 的封装函数就创建出来了。在 FP 语言中 currying 就这么简单：一种可以快速且简单的实现函数封装的捷径。我们可以更专注于自己的设计，编译器则会为你编写正确的代码！什么时候使用 currying 呢？很简单，当你想要用适配器模式（或是封装函数）的时候，就是用 currying 的时候。 惰性求值 惰性求值（或是延迟求值）是一种有趣的技术，而当我们投入函数式编程的怀抱后这种技术就有了得以实现的可能。前面介绍并发执行的时候已经提到过如下代码： String s1 = somewhatLongOperation1(); String s2 = somewhatLongOperation2(); String s3 = concatenate(s1, s2); 在指令式语言中以上代码执行的顺序是显而易见的。由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行。先是计算 somewhatLongOperation1，然后到 somewhatLongOperation2，最后执行 concatenate。函数式语言就不一样了。 在前面讨论过，somewhatLongOperation1 和 somewhatLongOperation2 是可以并发执行的，因为函数式语言保证了一点：没有函数会影响或者依赖于全局状态。可是万一我们不想要这两个函数并发执行呢？这种情况下是不是也还是要顺序执行这些函数？答案是否定的。只有到了执行需要 s1、s2 作为参数的函数的时候，才真正需要执行这两个函数。于是在 concatenate 这个函数没有执行之前，都没有需要去执行这两个函数：这些函数的执行可以一直推迟到 concatenate()中需要用到 s1 和 s2 的时候。假如把 concatenate 换成另外一个函数，这个函数中有条件判断语句而且实际上只会需要两个参数中的其中一个，那么就完全没有必要执行计算另外一个参数的函数了！Haskell 语言就是一个支持惰性求值的例子。Haskell 不能保证任何语句会顺序执行（甚至完全不会执行到），因为 Haskell 的代码只有在需要的时候才会被执行到。 除了这些优点，惰性求值也有缺点。这里介绍了它的优点，我们将在下一章节介绍这些缺点以及如何克服它们。 代码优化 惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。在此基础上优化是不会破坏代码正常运行的。严格使用形式系统的基本元素进行编程带来的最大的好处，是可以用数学方法分析处理代码，因为这样的程序是完全符合数学法则的。 抽象化控制结构 惰性求值技术提供了更高阶的抽象能力，这提供了实现程序设计独特的方法。比如说下面的控制结构： unless(stock.isEuropean()) { sendToSEC(stock); } 程序中除了在 stock 为 European 的时候都会执行 sendToSEC。如何实现例子中的 unless？如果没有惰性求值就需要求助于某种形式的宏（译者：用 if 不行么？），不过在像 Haskell 这样的语言中就不需要那么麻烦了。直接实现一个 unless 函数就可以！ void unless(boolean condition, List code) { if(!condition) code; } 请注意，如果 condition 值为真，那就不会计算 code。在其他严格语言（见严格求值）中这种行为是做不到的，因为在进入 unless 这个函数之前，作为参数的 code 已经被计算过了。 无穷数据结构 惰性求值技术允许定义无穷数据结构，这要在严格语言中实现将非常复杂。例如一个储存 Fibonacci 数列数字的列表。很明显这样一个列表是无法在有限的时间内计算出这个无穷的数列并存储在内存中的。在像 Java 这样的严格语言中，可以定义一个 Fibonacci 函数，返回这个序列中的某个数。而在 Haskell 或是类似的语言中，可以把这个函数进一步抽象化并定义一个 Fibonacci 数列的无穷列表结构。由于语言本身支持惰性求值，这个列表中只有真正会被用到的数才会被计算出来。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们（比如可以在一个列表处理函数中处理无穷多数据的列表）。 不足之处 俗话说天下没有免费的午餐 ™。惰性求值当然也有其缺点。其中最大的一个就是，嗯，惰性。现实世界中很多问题还是需要严格求值的。比如说下面的例子： System.out.println(&quot;Please enter your name: &quot;); System.in.readLine(); 在惰性语言中没人能保证第一行会在第二行之前执行！这也就意味着我们不能处理 IO，不能调用系统函数做任何有用的事情（这些函数需要按照顺序执行，因为它们依赖于外部状态），也就是说不能和外界交互了！如果在代码中引入支持顺序执行的代码原语，那么我们就失去了用数学方式分析处理代码的优势（而这也意味着失去了函数式编程的所有优势）。幸运的是我们还不算一无所有。数学家们研究了不同的方法用以保证代码按一定的顺序执行（in a functional setting?）。这一来我们就可以同时利用到函数式和指令式编程的优点了！这些方法有 continuations，monads 以及 uniqueness typing。这篇文章仅仅介绍了 continuations，以后再讨论 monads 和 uniqueness typing。有意思的是呢，coutinuations 处理强制代码以特定顺序执行之外还有其他很多用处，这些我们在后面也会提及。 Continuation continuation 对于编程，就像是达芬奇密码对于人类历史一样：它揭开了人类有史以来最大的谜团。好吧，也许没有那么夸张，不过它们的影响至少和当年发现负数有平方根不相上下。 我们对函数的理解只有一半是正确的，因为这样的理解基于一个错误的假设：函数一定要把其返回值返回给调用者。按照这样的理解，continuation 就是更加广义的函数。这里的函数不一定要把返回值传回给调用者，相反，它可以把返回值传给程序中的任意代码。continuation 就是一种特别的参数，把这种参数传到函数中，函数就能够根据 continuation 将返回值传递到程序中的某段代码中。说得很高深，实际上没那么复杂。直接来看看下面的例子好了： int i = add(5, 10); int j = square(i); add 这个函数将返回 15 然后这个值会赋给 i，这也是 add 被调用的地方。接下来 i 的值又会被用于调用 square。请注意支持惰性求值的编译器是不能打乱这段代码执行顺序的，因为第二个函数的执行依赖于第一个函数成功执行并返回结果。这段代码可以用 Continuation Pass Style（CPS）技术重写，这样一来 add 的返回值就不是传给其调用者，而是直接传到 square 里去了。 int j = add(5, 10, square); 在上例中，add 多了一个参数：一个函数，add 必须在完成自己的计算后，调用这个函数并把结果传给它。这时 square 就是 add 的一个 continuation。上面两段程序中 j 的值都是 225。 这样，我们学习到了强制惰性语言顺序执行两个表达式的第一个技巧。再来看看下面 IO 程序（是不是有点眼熟？）： System.out.println(&quot;Please enter your name: &quot;); System.in.readLine(); 这两行代码彼此之间没有依赖关系，因此编译器可以随意的重新安排它们的执行顺序。可是只要用 CPS 重写它，编译器就必须顺序执行了，因为重写后的代码存在依赖关系了。 System.out.println(&quot;Please enter your name: &quot;, System.in.readLine); 这段新的代码中 println 需要结合其计算结果调用 readLine，然后再返回 readLine 的返回值。这使得两个函数得以保证按顺序执行而且 readLine 总被执行（这是由于整个运算需要它的返回值作为最终结果）。Java 的 println 是没有返回值的，但是如果它可以返回一个能被 readLine 接受的抽象值，问题就解决了！（译者：别忘了，这里作者一开始就在 Java 的基础上修改搭建自己的语言）当然，如果一直把函数按照这种方法串下去，代码很快就变得不可读了，可是没有人要求你一定要这样做。可以通过在语言中添加语法糖的方式来解决这个问题，这样程序员只要按照顺序写代码，编译器负责自动把它们串起来就好了。于是就可以任意安排代码的执行顺序而不用担心会失去 FP 带来的好处了（包括可以用数学方法来分析我们的程序）！如果到这里还有人感到困惑，可以这样理解，函数只是有唯一成员的类的实例而已。试着重写上面两行程序，让 println 和 readLine 变成这种类的实例，所有问题就都搞清楚了。 到这里本章基本可以结束了，而我们仅仅了解到 continuation 的一点皮毛，对它的用途也知之甚少。我们可以用 CPS 完成整个程序，程序里所有的函数都有一个额外的 continuation 作为参数接受其他函数的返回值。还可以把任何程序转换为 CPS 的，需要做的只是把当中的函数看作是特殊的 continuation（总是将返回值传给调用者的 continuation）就可以了，简单到完全可以由工具自动完成（史上很多编译器就是这样做的）。 一旦将程序转为 CPS 的风格，有些事情就变得显而易见了：每一条指令都会有一些 continuation，都会将它的计算结果传给某一个函数并调用它，在一个普通的程序中这个函数就是该指令被调用并且返回的地方。随便找个之前提到过的代码，比如说 add(5,10)好了。如果 add 属于一个用 CPS 风格写出的程序，add 的 continuation 很明显就是当它执行结束后要调用的那个函数。可是在一个非 CPS 的程序中，add 的 continuation 又是什么呢？当然我们还是可以把这段程序转成 CPS 的，可是有必要这样做吗？ 事实上没有必要。注意观察整个 CPS 转换过程，如果有人尝试要为 CPS 程序写编译器并且认真思考过就会发现：CPS 的程序是不需要栈的！在这里完全没有函数需要做传统意义上的“返回”操作，函数执行完后仅需要接着调用另外一个函数就可以了。于是就不需要在每次调用函数的时候把参数压栈再将它们从中取出，只要把这些参数存放在一片内存中然后使用跳转指令就解决问题了。也完全不需要保留原来的参数：因为这种程序里的函数都不返回，所以它们不会被用第二次！ 简单点说呢，用 CPS 风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。非 CPS 风格的程序不需要额外的参数但又需要栈才能运行。栈里面存的是什么？仅仅是参数还有一个供函数运行结束后返回的程序指针而已。这个时候你是不是已经恍然大悟了？对啊，栈里面的数据实际上就是 continuation 的信息！栈上的程序返回指针实质上就是 CPS 程序中需要调用的下一个函数！想要知道 add(5, 10)的 continuation 是什么？只要看它运行时栈的内容就可以了。 接下来就简单多了。continuation 和栈上指示函数返回地址的指针其实是同一样东西，只是 continuation 是显式的传递该地址并且因此代码就不局限于只能返回到函数被调用的地方了。前面说过，continuation 就是函数，而在我们特制的语言中函数就是类的实例，那么可以得知栈上指向函数返回地址的指针和 continuation 的参数是一样的，因为我们所谓的函数（就像类的一个实例）其实就是指针。这也意味着在程序运行的任何时候，你都可以得到当前的 continuation（就是栈上的信息）。 好了，我们已经搞清楚当前的 continuation 是什么了。接下来要弄明白它的存在有什么意义。只要得到了当前的 continuation 并将它保存起来，就相当于保存了程序的当前状态：在时间轴上把它冻结起来了。这有点像操作系统进入休眠状态。continuation 对象保存了足够的信息随时可以从指定的某个状态继续运行程序。在切换线程的时候操作系统也是这样做的。唯一的区别在于它保留了所有的控制权利。当请求某个 continuation 对象时（在 Scheme 语言中是通过调用 call-with-current-continuation 函数实现的）得到的是一个存有当前 continuation 的对象，也就是栈对象（在 CPS 中也就是下一个要执行的函数）。可以把这个对象保存做一个变量中（或者是存在磁盘上）。当以该 continuation 对象“重启”该程序时，程序的状态就会立即“转换”为该对象中保存的状态。这一点和切换回一个被暂停的线程或是从系统休眠中唤醒很相像，唯一不同的是 continuatoin 对象可以反复的这样使用。当系统唤醒后，休眠前保存的信息就会销毁，否则你也可以反复的从该点唤醒系统，就像乘时光机回到过去一样。有了 continuation 你就可以做到这一点！ 那么 continuation 在什么情况下有用呢？有一些应用程序天生就没有状态，如果要在这样的系统中模拟出状态以简化工作的时候，就可以用到 continuation。最合适的应用场合之一就是网页应用程序。微软的 ASP.NET 为了让程序员更轻松的编写应用程序，花了大量的精力去模拟各种状态。假如 C#支持 continuation 的话，那么 ASP.NET 的复杂度将减半：因为只要把某一时刻的 continuation 保存起来，下次用户再次发起同样请求的时候，重新载入这个 continuation 即可。对于网络应用的程序员来说就再也没有中断了：轻轻松松程序就从下一行开始继续运行了！对于一些实际问题来说，continuation 是一种非常有用的抽象工具。如今大量的传统胖客户端（见瘦客户端）正纷纷走进网络，continuation 在未来将扮演越来越重要的角色。 模式匹配 模式匹配并不是什么新功能。而事实上它和函数式编程也没有什么太大的关系。它之所以常常被认为是 FP 的一个特性，是因为在函数式语言已经支持模式匹配很长一段时间后的今天，指令式语言是还没有这个功能。 还是直接用例子来看看什么是模式匹配吧，这是一个用 Java 写的 Fibonacci 函数： int fib(int n) { if(n == 0) return 1; if(n == 1) return 1; return fib(n - 2) + fib(n - 1); } 再看看用我们基于 Java 修改过的新语言写出来的 Fibonacci 函数，这种新语言就支持模式匹配： int fib(0) { return 1; } int fib(1) { return 1; } int fib(int n) { return fib(n - 2) + fib(n - 1); } 区别在哪里呢？在于后者的编译器替我们实现了程序的分支。 这有什么了不起的？确实也没什么。只是有人注意到很多函数中有非常复杂的 switch 结构（对于函数式程序而言更是如此），于是想到如果能把这层结构也抽象化就更好了。然后就把这个复杂的函数拆分成若干新的函数，并在这些函数的某些参数中应用模式（这和重载有点类似）。当这个函数被调用的时候，编译器会在运行时将调用者传入的参数与各个新函数的参数定义进行比较，找出合适的那个函数来执行。合适的函数往往是参数定义上最具体最接近传入参数的那个函数。在这个例子中，当 n 为 1 时，可以用函数 int fib(int n)，不过真正调用的是 int fib(1)因为这个函数更具体更接近调用者的要求。 模式匹配一般来说要比这里举的例子更加复杂。比如说，高级模式匹配系统可以支持下面的操作： int f(int n &lt; 10) { ... } int f(int n) { ... } 那么什么情况下模式匹配会有用呢？在需要处理一大堆程序分支的时候！每当需要实现复杂的嵌套 if 语句的时候，模式匹配可以帮助你用更少的代码更好的完成任务。我所知道的一个这样的函数是标准的 WndProc 函数，该函数是所有 Win32 应用程序必须具备的（尽管它经常会被抽象化）。模式匹配系统一般都可以像匹配简单数值一样匹配数据集合。举个例子，对于一个接受数组作为参数的函数，可以通过模式匹配数组中第一个数字为 1 并且第三个数字大于 3 的输入。 模式匹配的另外一个好处是每当需要添加或者修改程序分支时，再也不用面对那个庞大臃肿的函数了。只要添加（或者修改）相关的函数定义即可。有了模式匹配就不再需要四人帮的很多设计模式了。程序分支越多越复杂，模式匹配就越有用。而在习惯使用这一技术之后，你可能会怀疑没有它你一天都过不下去了。 Closure 目前为止关于函数式编程各种功能的讨论都只局限在“纯”函数式语言范围内：这些语言都是 lambda 演算的实现并且都没有那些和阿隆佐形式系统相冲突的特性。然而，很多函数式语言的特性哪怕是在 lambda 演算框架之外都是很有用的。确实，如果一个公理系统的实现可以用数学思维来看待程序，那么这个实现还是很有用的，但这样的实现却不一定可以付诸实践。很多现实中的语言都选择吸收函数式编程的一些元素，却又不完全受限于函数式教条的束缚。很多这样的语言（比如 Common Lisp）都不要求所有的变量必须为 final，可以修改他们的值。也不要求函数只能依赖于它们的参数，而是可以读写函数外部的状态。同时这些语言又包含了 FP 的特性，如高阶函数。与在 lambda 演算限制下将函数作为参数传递不同，在指令式语言中要做到同样的事情需要支持一个有趣的特性，人们常把它称为 lexical closure。还是来看看例子。要注意的是，这个例子中变量不是 final，而且函数也可以读写其外部的变量： Function makePowerFn(int power) { int powerFn(int base) { return pow(base, power); } return powerFn; } Function square = makePowerFn(2); square(3); // returns 9 makePowerFn 函数返回另一个函数，这个新的函数需要一个整数参数然后返回它的平方值。执行 square(3)的时候具体发生了什么事呢？变量 power 并不在 powerFn 的域内，因为 makePowerFn 早就运行结束返回了，所以它的栈也已经不存在了。那么 square 又是怎么正常工作的呢？这个时候需要语言通过某种方式支持继续存储 power 的值，以便 square 后面继续使用。那么如果再定义一个函数，cube，用来计算立方，又应该怎么做呢？那么运行中的程序就必须存储两份 power 的值，提供给 makePowerFn 生成的两个函数分别使用。这种保存变量值的方法就叫做 closure。closure 不仅仅保存宿主函数的参数值，还可以用在下例的用法中： Function makeIncrementer() { int n = 0; int increment() { return ++n; } } Function inc1 = makeIncrementer(); Function inc2 = makeIncrementer(); inc1(); // returns 1; inc1(); // returns 2; inc1(); // returns 3; inc2(); // returns 1; inc2(); // returns 2; inc2(); // returns 3; 运行中的程序负责存储 n 的值，以便 incrementer 稍后可以访问它。与此同时，程序还会保存多份 n 的拷贝，虽然这些值应该在 makeIncrementer 返回后就消失，但在这个情况下却继续保留下来给每一个 incrementer 对象使用。这样的代码编译之后会是什么样子？closure 幕后的真正工作机理又是什么？这次运气不错，我们有一个后台通行证，可以一窥究竟。 一点小常识往往可以帮大忙。乍一看这些本地变量已经不再受限于基本的域限制并拥有无限的生命周期了。于是可以得出一个很明显的结论：它们已经不是存在栈上，而是堆上了8。这么说来 closure 的实现和前面讨论过的函数差不多，只不过 closure 多了一个额外的引用指向其外部的变量而已： class some_function_t { SymbolTable parentScope; // ... } 当 closure 需要访问不在它本地域的变量时，就可以通过这个引用到更外一层的父域中寻找该变量。谜底揭开了！closure 将函数编程与面向对象的方法结合了起来。下一次为了保存并传递某些状态而创建类的时候，想想 closure。它能在运行时从相应的域中获得变量，从而可以把该变量当成“成员变量”来访问，也因为这样，就不再需要去创建一个成员变量了。 路在何方？ 这篇文章仅仅涉及到函数式编程的一些皮毛。考虑到有时候星星之火可以燎原，所以如果它能给你一些帮助那就再好不过了。接下来我计划就范畴论、monads、函数式编程数据结构、函数式语言中的类型系统、并行函数式编程、数据库的函数式编程以及更多的话题写些类似的文章。如果我可以写出（在我学习的同时）以上清单的一半，我的人生就完整了。于此同时，Google 将是我们的良师益友。 欢迎联系 如果您有任何问题，评价或者建议，请发邮件到 coffeemug@gmail.com（译者：如果翻译方面的问题／建议请发到 yang.huang@ymail.com:)）。期待您的回复。 注： 1当我在 2005 年求职时的的确确经常问别人这个问题。看着那些茫然的面孔实在是很好玩的事情。你们这些年薪 30 万美金的家伙，至少应该对自己可以利用的工具有个起码的理解嘛。↩ 2这是个有争议的问题。物理学家和数学家不得不承认目前还无法确定宇宙万物是不是都遵从可以用数学方法描述的各种法则。↩ 3我一直一来都很讨厌在历史课上罗列一堆枯燥无味的时间、人名、事件。对我来说历史就是关于那些改变世界的人们活生生的故事，是他们行为背后的个人动机，是那些他们用以影响芸芸众生的方法和工具。从这个角度来说，接下来的这堂历史课是不完整的，很遗憾。只有那些非常相关的人和事会被提及。↩ 4在我学习函数式编程的时候，“lambda”这个术语搞得我很烦，因为我不知道它到底是什么意思。在这里 lambda 就是一个函数，在数学符号中用这个希腊字母只是因为它更容易写。所以以后在谈及函数式编程的时候只要你听到 lambda，把它在脑中翻译为“函数”就可以了。↩ 5有意思的是不论如何 Java 中的字符串总是不可修改的。讨论这种背叛 Java 的设计背后的原因会很有意思，可惜这样会让我们跑题的。↩ 6大部分函数式语言的编译器都会尽量将迭代函数转换为对等的循环语句。这种做法叫做尾调用优化。↩ 7反之则不一定成立。尽管有时候可以证明两段代码是等价的，但不是在所有的情况下都可以得出这样的结论。↩ 8实际上这样做并不比栈上存储要慢，因为在引入垃圾回收机制后，内存分配操作的时间代价仅为 O(1)。↩ ","link":"https://Eakamm.github.io/post/sha-gua-han-shu-shi-bian-cheng-zhuan-zai/"},{"title":"ES6语法箭头函数","content":"优雅的函数式编程 1、之前的函数定义方式 1、Function let a = function(){ } 2、对象字面量添加函数 let b = { b: function(){}, b2(){} } 2、箭头函数 1、放入一个参数 let a = num1 =&gt; { return ++num1 } 2、放入两个参数 let a = （num1, num2） =&gt; { return num2+num1 } 3、函数中只有一行代码 当函数中只有一行代码的时候，无论是return还是普通代码，均可以使用增强写法。 // 原来 let a = (c) =&gt; { return ++c } // 增强写法 let a = c =&gt; ++c 2、this 箭头函数的作用域是从当前位置向外一层一层找，直到找到一个this const aa = { bb(){ setTimeout(() =&gt; { console.log(this) }) }, cc(){ setTimeout(function(){ console.log(this) }) } } aa.bb() aa.cc() ","link":"https://Eakamm.github.io/post/es6-yu-fa-jian-tou-han-shu/"},{"title":"Mysql进行时间查询的一些常用sql","content":"经常用到，防止忘掉，随查随用 1、时间段查询 -- 今天 select fullName,addedTime from t_user where to_days(addedTime) &lt;= to_days(now()); -- 昨天 select fullName,addedTime from t_user where to_days(NOW()) - TO_DAYS(addedTime) &lt;= 1; -- 近7天 select fullName,addedTime from t_user where date_sub(CURDATE(),INTERVAL 7 DAY) &lt;= DATE(addedTime); -- 近30天 SELECT fullName,addedTime FROM t_user where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(addedTime); -- 本月 SELECT fullName,addedTime FROM t_user WHERE DATE_FORMAT( addedTime, '%Y%m' ) = DATE_FORMAT( CURDATE() , '%Y%m' ); -- 上一月 SELECT fullName,addedTime FROM t_user WHERE PERIOD_DIFF( date_format( now( ) , '%Y%m' ) , date_format( addedTime, '%Y%m' ) ) =1; -- 查询本季度数据 select fullName,addedTime FROM t_user where QUARTER(addedTime)=QUARTER(now()); -- 查询上季度数据 select fullName,addedTime FROM t_user where QUARTER(addedTime)=QUARTER(DATE_SUB(now(),interval 1 QUARTER)); -- 查询本年数据 select fullName,addedTime FROM t_user where YEAR(addedTime)=YEAR(NOW()); -- 查询上年数据 select fullName,addedTime FROM t_user where year(addedTime)=year(date_sub(now(),interval 1 year)); -- 查询距离当前现在6个月的数据 select fullName,addedTime FROM t_user where addedTime between date_sub(now(),interval 6 month) and now(); -- 查询当前这周的数据 SELECT fullName,addedTime FROM t_user WHERE YEARWEEK(date_format(addedTime,'%Y-%m-%d')) = YEARWEEK(now()); -- 查询上周的数据 SELECT fullName,addedTime FROM t_user WHERE YEARWEEK(date_format(addedTime,'%Y-%m-%d')) = YEARWEEK(now())-1; -- 查询上个月的数据 select fullName,addedTime FROM t_user where date_format(addedTime,'%Y-%m')=date_format(DATE_SUB(curdate(), INTERVAL 1 MONTH),'%Y-%m'); -- 查询当前月份的数据 select fullName,addedTime FROM t_user where DATE_FORMAT(addedTime,'%Y%m') = DATE_FORMAT(CURDATE(),'%Y%m'); select fullName,addedTime FROM t_user where date_format(addedTime,'%Y-%m')=date_format(now(),'%Y-%m'); -- 查询指定时间段的数据 select fullName,addedTime FROM t_user where addedTime between '2017-1-1 00:00:00' and '2018-1-1 00:00:00'; select fullName,addedTime FROM t_user where addedTime &gt;='2017-1-1 00:00:00' and addedTime &lt; '2018-1-1 00:00:00'; 2、时间分组查询 1、查询方式 &lt;!-- 按日查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%m-%d') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按月查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%m') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按年查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time &lt;!-- 按周查询 --&gt; SELECT DATE_FORMAT(created_date,'%Y-%u') as time,sum(money) money FROM o_finance_detail where org_id = 1000 GROUP BY time 2、时间格式化规则 DATE_FORMAT(date,format) 根据format字符串格式化date值。下列修饰符可以被用在format字符串中： 符号 描述 %M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”。 ","link":"https://Eakamm.github.io/post/mysql-jin-xing-shi-jian-cha-xun-de-yi-xie-chang-yong-sql/"},{"title":"ElementUI的<el-col>标签无法使用点击事件","content":"今天在做一个点击的组件，是由标签包裹的如下: &lt;el-row class=&quot;panel-group&quot;&gt; &lt;el-col :xs=&quot;12&quot; :sm=&quot;12&quot; :lg=&quot;8&quot; class=&quot;.card-panel-col&quot; @click=&quot;handleSetLineChartData(1)&quot;&gt; &lt;panel-group2 :value='baseStatistics.inMoneyTotals' title=&quot;当年入库总金额&quot; iconName=&quot;peoples&quot;&gt;&lt;/panel-group2&gt; &lt;/el-col&gt; &lt;/el-row&gt; 使用@click后点击并没有效果，通过查找发现使用 &lt;el-row class=&quot;panel-group&quot;&gt; &lt;el-col :xs=&quot;12&quot; :sm=&quot;12&quot; :lg=&quot;8&quot; class=&quot;.card-panel-col&quot; @click.native=&quot;handleSetLineChartData(1)&quot;&gt; &lt;panel-group2 :value='baseStatistics.inMoneyTotals' title=&quot;当年入库总金额&quot; iconName=&quot;peoples&quot;&gt;&lt;/panel-group2&gt; &lt;/el-col&gt; &lt;/el-row&gt; 使用@click.native可以监听点击事件了😵😵 ","link":"https://Eakamm.github.io/post/elementui-de-lessel-colgreaterbiao-qian-wu-fa-shi-yong-dian-ji-shi-jian/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://Eakamm.github.io/post/hello-gridea/"}]}